var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"S. Billey and V. Lakshmibai. Singular loci of Schubert varieties. Vol. 182 of Progress in Mathematics (Birkhäuser Boston, Inc., Boston, MA, 2000); p. xii+251.\n\n\n\nS. Billey and A. Postnikov. Smoothness of Schubert varieties via patterns in root               subsystems. Adv. in Appl. Math. 34, 447–466 (2005).\n\n\n\nI. Charton and L. Kessler. Monotone Symplectic Six-Manifolds that admit a Hamiltonian GKM Action are diffeomorphic to Smooth Fano Threefolds (2023), https://arxiv.org/abs/2308.10541.\n\n\n\nD. A. Cox and S. Katz. Mirror symmetry and algebraic geometry. Vol. 68 of Mathematical Surveys and Monographs (American Mathematical Society, Providence, RI, 1999); p. xxii+469.\n\n\n\nO. Goertsches, P. Konstantis and L. Zoller. Realization of GKM fibrations and new examples of               Hamiltonian non-Kähler actions. Compos. Math. 159, 2149–2190 (2023).\n\n\n\nO. Goertsches, P. Konstantis and L. Zoller. Low-dimensional GKM theory. In: Group actions and equivariant cohomology, Vol. 808 of Contemp. Math. (Amer. Math. Soc., [Providence], RI, 2024); pp. 113–146.\n\n\n\nM. Goresky, R. Kottwitz and R. MacPherson. Equivariant cohomology, Koszul duality, and the localization               theorem. Invent. Math. 131, 25–83 (1998).\n\n\n\nV. Guillemin and C. Zara. Equivariant de Rham theory and graphs. In: Surveys in differential geometry, Vol. 7 of Surv. Differ. Geom. (Int. Press, Somerville, MA, 2000); pp. 221–257.\n\n\n\nV. Guillemin and C. Zara. 1-skeleta, Betti numbers, and equivariant cohomology. Duke Math. J. 107, 283–349 (2001).\n\n\n\nV. Guillemin, S. Sabatini and C. Zara. Cohomology of GKM fiber bundles. J. Algebraic Combin. 35, 19–59 (2012).\n\n\n\nH. Iritani. Shift operators and toric mirror theorem. Geom. Topol. 21, 315–343 (2017).\n\n\n\nS. Kumar. The nil Hecke ring and singularity of Schubert varieties. Invent. Math. 123, 471–506 (1996).\n\n\n\nC.-C. M. Liu and A. Sheshmani. Equivariant Gromov–Witten invariants of algebraic GKM               manifolds. SIGMA Symmetry Integrability Geom. Methods Appl. 13, Paper No. 048, 21 (2017).\n\n\n\nD. Maulik and A. Okounkov. Quantum groups and quantum cohomology. Astérisque, ix+209 (2019).\n\n\n\nD. McDuff and D. Salamon. J-holomorphic curves and symplectic topology. Second Edition, Vol. 52 of American Mathematical Society Colloquium Publications (American Mathematical Society, Providence, RI, 2012); p. xiv+726.\n\n\n\nD. Mumford, J. Fogarty and F. Kirwan. Geometric invariant theory. Third Edition, Vol. 34 of Ergebnisse der Mathematik und ihrer Grenzgebiete (2) [Results               in Mathematics and Related Areas (2)] (Springer-Verlag, Berlin, 1994); p. xiv+292.\n\n\n\nR. A. Wright, B. Richmond, A. Odlyzko and B. D. McKay. Constant time generation of free trees. SIAM J. Comput. 15, 540–548 (1986).\n\n\n\n","category":"page"},{"location":"GKM/STDconstructions/#Standard-Constructions","page":"Standard Constructions","title":"Standard Constructions","text":"","category":"section"},{"location":"GKM/STDconstructions/","page":"Standard Constructions","title":"Standard Constructions","text":"In this section we present some functions that allow the construction of famous GKM graphs.","category":"page"},{"location":"GKM/STDconstructions/#Generalized-Flags-Varieties","page":"Standard Constructions","title":"Generalized Flags Varieties","text":"","category":"section"},{"location":"GKM/STDconstructions/#GKMtools.generalized_gkm_flag","page":"Standard Constructions","title":"GKMtools.generalized_gkm_flag","text":"generalized_gkm_flag(R::RootSystem, S::Vector{RootSpaceElem}) -> AbstractGKM_graph\n\nGiven a root system R and a subset S of the set of simple roots, it constructs the  GKM graph of the generalized flag variety GP. Here G is the simply-connected complex Lie group  with root system R, and P is the parabolic subgroup with root system S. If S is empty, it construct GB where B is a Borel subgroup. The vertices of GP correspond to the cosets WW_P where W (resp., W_P) is the Weyl group of G (resp., P). The label of a vertex is the unique element of minimal length in the corresponding coset.\n\nnote: Note\nThe character group is of type free mathbbZ-module if R is of type A B C D G. It is a free mathbbQ-module if R is of type E or F.\n\nwarning: Warning\nComputing this function with root systems of very large Weyl groups may be slow.\n\nExamples\n\njulia> A1xA1 = root_system([(:A, 1), (:A, 1)])\nRoot system of rank 2\n  of type A1 x A1\n\njulia> generalized_gkm_flag(A1xA1)\nGKM graph with 4 nodes, valency 2 and axial function:\ns1 -> id => (-1, 1, 0, 0)\ns2 -> id => (0, 0, -1, 1)\ns1*s2 -> s1 => (0, 0, -1, 1)\ns1*s2 -> s2 => (-1, 1, 0, 0)\n\njulia> RC3 = root_system(:C, 3)\nRoot system of rank 3\n  of type C3\n\njulia> gp1 = generalized_gkm_flag(RC3);\n\njulia> rank_torus(gp1)\n3\n\njulia> R = root_system([(:A, 1), (:G, 2)])\nRoot system of rank 3\n  of type A1 x G2\n\njulia> S = [simple_roots(R)[3]];\n\njulia> gp2 = generalized_gkm_flag(R, S);\n\njulia> rank_torus(gp2)\n5\n\n\n\n\n\n\ngeneralized_gkm_flag(R::RootSystem; indices_of_S) -> AbstractGKM_graph\n\nSame as before, but indicating the indices of the roots in S instead of the roots itself.\n\nExamples\n\njulia> R = root_system(matrix(ZZ, [2 -1 -2; -1 2 0; -1 0 2]))\nRoot system of rank 3\n  of type C3 (with non-canonical ordering of simple roots)\n\njulia> gp1 = generalized_gkm_flag(R, 2:3);\n\njulia> valency(gp1)\n7\n\njulia> gp2 = generalized_gkm_flag(R, [1,2]);\n\njulia> rank_torus(gp2)\n3\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#GKMtools.flag_variety","page":"Standard Constructions","title":"GKMtools.flag_variety","text":"flag_variety(::Type{GKM_graph}, s::Vector{Int64}) -> AbstractGKM_graph{ZZRingElem}\n\nConstruct the GKM graph of the variety of flags of mathbbC^n. The dimensions of quotients are expressed by the array s. The labels represent the vectors generating the flags. For example, if s=121, the string 213 corresponds to the flag:\n\n0subset langle e_2 rangle subset langle e_2 e_1 e_3 rangle subset langle e_2 e_1 e_3 e_4 rangle=mathbbC^4\n\nnote: Note\nThis function is faster than generalized_gkm_flag(root_system(:A, n-1), S), but the results are isomorphic.\n\nExamples\n\njulia> flag_variety(GKM_graph, [1,3])\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\n\njulia> flag_variety(GKM_graph, [2,1])\nGKM graph with 3 nodes, valency 2 and axial function:\n13 -> 12 => (0, -1, 1)\n23 -> 12 => (-1, 0, 1)\n23 -> 13 => (-1, 1, 0)\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#GKMtools.grassmannian","page":"Standard Constructions","title":"GKMtools.grassmannian","text":"grassmannian(::Type{gkm_graph}, k::Int, n::Int) -> AbstractGKM_graph{ZZRingElem}\n\nConstruct the Grassmann variety of k-planes in the complex vector space of dimension n.\n\nExamples\n\njulia> grassmannian(GKM_graph, 2, 4)\nGKM graph with 6 nodes, valency 4 and axial function:\n13 -> 12 => (0, -1, 1, 0)\n14 -> 12 => (0, -1, 0, 1)\n14 -> 13 => (0, 0, -1, 1)\n23 -> 12 => (-1, 0, 1, 0)\n23 -> 13 => (-1, 1, 0, 0)\n24 -> 12 => (-1, 0, 0, 1)\n24 -> 14 => (-1, 1, 0, 0)\n24 -> 23 => (0, 0, -1, 1)\n34 -> 13 => (-1, 0, 0, 1)\n34 -> 14 => (-1, 0, 1, 0)\n34 -> 23 => (0, -1, 0, 1)\n34 -> 24 => (0, -1, 1, 0)\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Oscar.projective_space","page":"Standard Constructions","title":"Oscar.projective_space","text":"projective_space(::Type{gkm_graph}, d::Int)\n\nConstruct the projective space of dimension d.\n\nExamples\n\njulia> projective_space(GKM_graph, 2)\nGKM graph with 3 nodes, valency 2 and axial function:\n2 -> 1 => (-1, 1, 0)\n3 -> 1 => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Generalized-Schubert-Varieties","page":"Standard Constructions","title":"Generalized Schubert Varieties","text":"","category":"section"},{"location":"GKM/STDconstructions/#GKMtools.get_bruhat_order_of_generalized_flag","page":"Standard Constructions","title":"GKMtools.get_bruhat_order_of_generalized_flag","text":"get_bruhat_order_of_generalized_flag(R::RootSystem, S::Vector{RootSpaceElem}; descending::Bool=true) -> BruhatOrder\n\nIt returns the Bruhat order of the generalized flag variety given by the root system R with the subset of simple roots given by S. See generalized_gkm_flag. If descending is true, the Bruhat order is given from the elements of maximal length to the smallest.\n\nExamples\n\njulia> R = root_system(:A, 3);\n\njulia> S = simple_roots(R);\n\njulia> get_bruhat_order_of_generalized_flag(R, S[1:2])\nBruhat order in descending order:\nLength: 3\n  s1*s2*s3 => [\"s2*s3\"]\nLength: 2\n  s2*s3 => [\"s3\"]\nLength: 1\n  s3 => [\"id\"]\nLength: 0\n  id\n\n\n\n\n\n\nget_bruhat_order_of_generalized_flag(R::RootSystem, indices_of_S; descending::Bool=true) -> BruhatOrder\n\nSame as before, but indicating the indices of the roots in S instead of the roots itself.\n\nExamples\n\njulia> R = root_system(:A, 3);\n\njulia> get_bruhat_order_of_generalized_flag(R, [1]; descending = false)\nBruhat order in ascending order:\nLength: 0\n  id => [\"s2\", \"s3\"]\nLength: 1\n  s2 => [\"s1*s2\", \"s3*s2\", \"s2*s3\"]\n  s3 => [\"s3*s2\", \"s2*s3\"]\nLength: 2\n  s2*s3 => [\"s2*s3*s2\", \"s1*s2*s3\"]\n  s1*s2 => [\"s1*s3*s2\", \"s1*s2*s3\"]\n  s3*s2 => [\"s1*s3*s2\", \"s2*s3*s2\"]\nLength: 3\n  s1*s2*s3 => [\"s1*s2*s3*s2\"]\n  s2*s3*s2 => [\"s2*s1*s3*s2\", \"s1*s2*s3*s2\"]\n  s1*s3*s2 => [\"s2*s1*s3*s2\", \"s1*s2*s3*s2\"]\nLength: 4\n  s2*s1*s3*s2 => [\"s1*s2*s1*s3*s2\"]\n  s1*s2*s3*s2 => [\"s1*s2*s1*s3*s2\"]\nLength: 5\n  s1*s2*s1*s3*s2\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#GKMtools.generalized_gkm_schubert","page":"Standard Constructions","title":"GKMtools.generalized_gkm_schubert","text":"generalized_gkm_schubert(R::RootSystem, indices_of_S::Vector{RootSpaceElem}, pt::String) -> AbstractGKM_subgraph\n\nLet G be the generalized flag variety given by the root system R with the subset of simple roots given by S. See generalized_gkm_flag. This functions returns the subgraph of the variety G given by all Schubert cells corresponding to the points less or equal to pt in the Bruhat order.\n\nExamples\n\njulia> R = root_system(:B, 2);\n\njulia> generalized_gkm_schubert(R, \"s1*s2\")\nGKM subgraph of:\nGKM graph with 8 nodes, valency 4 and axial function:\ns1 -> id => (-1, 1)\ns2*s1 -> s1 => (0, -1)\ns1*s2*s1 -> id => (-1, 0)\ns1*s2*s1 -> s2*s1 => (-1, 1)\ns2 -> id => (0, -1)\ns2 -> s2*s1 => (1, 1)\ns1*s2 -> s1 => (-1, 0)\ns1*s2 -> s1*s2*s1 => (1, 1)\ns1*s2 -> s2 => (-1, 1)\ns2*s1*s2 -> id => (-1, -1)\ns2*s1*s2 -> s2*s1 => (-1, 0)\ns2*s1*s2 -> s1*s2 => (0, -1)\ns1*s2*s1*s2 -> s1 => (-1, -1)\ns1*s2*s1*s2 -> s1*s2*s1 => (0, -1)\ns1*s2*s1*s2 -> s2 => (-1, 0)\ns1*s2*s1*s2 -> s2*s1*s2 => (-1, 1)\nSubgraph:\nGKM graph with 4 nodes, valency 2 and axial function:\ns1 -> id => (-1, 1)\ns2 -> id => (0, -1)\ns1*s2 -> s1 => (-1, 0)\ns1*s2 -> s2 => (-1, 1)\n\nAs before, the subset S can be a subset of simple roots or a subset of indices.\n\njulia> generalized_gkm_schubert(R, [1], \"s2\")\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\ns2 -> id => (0, -1)\ns1*s2 -> id => (-1, 0)\ns1*s2 -> s2 => (-1, 1)\ns2*s1*s2 -> id => (-1, -1)\ns2*s1*s2 -> s2 => (-1, 0)\ns2*s1*s2 -> s1*s2 => (0, -1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\ns2 -> id => (0, -1)\n\njulia> S = simple_roots(R);\n\njulia> generalized_gkm_schubert(R, [S[2]], \"s1\")\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\ns1 -> id => (-1, 1)\ns2*s1 -> id => (-1, -1)\ns2*s1 -> s1 => (0, -1)\ns1*s2*s1 -> id => (-1, 0)\ns1*s2*s1 -> s1 => (-1, -1)\ns1*s2*s1 -> s2*s1 => (-1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\ns1 -> id => (-1, 1)\n\n\n\n\n\n\ngeneralized_gkm_schubert(R::RootSystem, indices_of_S::Union{UnitRange{Int64}, Vector{Int64}}, pt::String)  -> AbstractGKM_subgraph\n\n\n\n\n\ngeneralized_gkm_schubert(R::RootSystem, pt::String) -> AbstractGKM_subgraph\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#GKMtools.bott_samelson","page":"Standard Constructions","title":"GKMtools.bott_samelson","text":"bott_samelson(S::Vector{RootSpaceElem}; printEdges::Bool = true)\n\nWe construct the Bott-Samelson desingularization of a Schubert variety given by S.\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Schubert-Classes","page":"Standard Constructions","title":"Schubert Classes","text":"","category":"section"},{"location":"GKM/STDconstructions/#Oscar.IntersectionTheory.schubert_class","page":"Standard Constructions","title":"Oscar.IntersectionTheory.schubert_class","text":"schubert_class(schubert::AbstractGKM_subgraph, BO::BruhatOrder, label::String)\n\nReturn the Poincare dual (as subvariety of the Schubert variety schubert) of the Schubert variety given by label.\n\nArguments\n\nschubert::AbstractGKM_subgraph: The Schubert variety given as GKM subgraph object of the corresponding generalized partial flag variety (as returned by generalized_gkm_schubert).\nBO::BruhatOrder: The Bruhat order on the generalized partial flag variety (as returned by get_bruhat_order_of_generalized_flag).\nlabel:String: The label of the Weyl group element or coset defining the Schubert variety as subvariety of the generalized partial flag variety.\n\nExample\n\njulia> R = root_system(:A, 3);\n\njulia> S = simple_roots(R);\n\njulia> BO = get_bruhat_order_of_generalized_flag(R, S[1:1]);\n\njulia> schubert = generalized_gkm_schubert(R, S[1:1], \"s1*s2*s3\")\nGKM subgraph of:\nGKM graph with 12 nodes, valency 5 and axial function:\ns2 -> id => (0, -1, 1, 0)\ns1*s2 -> id => (-1, 0, 1, 0)\ns1*s2 -> s2 => (-1, 1, 0, 0)\ns3*s2 -> s2 => (0, 0, -1, 1)\ns1*s3*s2 -> s1*s2 => (0, 0, -1, 1)\ns1*s3*s2 -> s3*s2 => (-1, 1, 0, 0)\ns2*s1*s3*s2 -> s1*s2 => (0, -1, 0, 1)\ns2*s1*s3*s2 -> s1*s3*s2 => (0, -1, 1, 0)\ns1*s2*s1*s3*s2 -> s2 => (-1, 0, 0, 1)\ns1*s2*s1*s3*s2 -> s3*s2 => (-1, 0, 1, 0)\ns1*s2*s1*s3*s2 -> s2*s1*s3*s2 => (-1, 1, 0, 0)\ns2*s3*s2 -> id => (0, -1, 0, 1)\ns2*s3*s2 -> s3*s2 => (0, -1, 1, 0)\ns2*s3*s2 -> s2*s1*s3*s2 => (1, 0, -1, 0)\ns1*s2*s3*s2 -> id => (-1, 0, 0, 1)\ns1*s2*s3*s2 -> s1*s3*s2 => (-1, 0, 1, 0)\ns1*s2*s3*s2 -> s1*s2*s1*s3*s2 => (0, 1, -1, 0)\ns1*s2*s3*s2 -> s2*s3*s2 => (-1, 1, 0, 0)\ns3 -> id => (0, 0, -1, 1)\ns3 -> s3*s2 => (0, 1, 0, -1)\ns3 -> s1*s3*s2 => (1, 0, 0, -1)\ns2*s3 -> s2 => (0, -1, 0, 1)\ns2*s3 -> s2*s1*s3*s2 => (1, 0, 0, -1)\ns2*s3 -> s2*s3*s2 => (0, 0, 1, -1)\ns2*s3 -> s3 => (0, -1, 1, 0)\ns1*s2*s3 -> s1*s2 => (-1, 0, 0, 1)\ns1*s2*s3 -> s1*s2*s1*s3*s2 => (0, 1, 0, -1)\ns1*s2*s3 -> s1*s2*s3*s2 => (0, 0, 1, -1)\ns1*s2*s3 -> s3 => (-1, 0, 1, 0)\ns1*s2*s3 -> s2*s3 => (-1, 1, 0, 0)\nSubgraph:\nGKM graph with 6 nodes, valency 3 and axial function:\ns2 -> id => (0, -1, 1, 0)\ns1*s2 -> id => (-1, 0, 1, 0)\ns1*s2 -> s2 => (-1, 1, 0, 0)\ns3 -> id => (0, 0, -1, 1)\ns2*s3 -> s2 => (0, -1, 0, 1)\ns2*s3 -> s3 => (0, -1, 1, 0)\ns1*s2*s3 -> s1*s2 => (-1, 0, 0, 1)\ns1*s2*s3 -> s3 => (-1, 0, 1, 0)\ns1*s2*s3 -> s2*s3 => (-1, 1, 0, 0)\n\njulia> schubert_class(schubert, BO, \"s1*s2\")\n(t3 - t4)*e[1] + (t2 - t4)*e[2] + (t1 - t4)*e[3]\n\njulia> schubert_class(schubert, BO, \"s1*s2*s3\")\ne[1] + e[2] + e[3] + e[4] + e[5] + e[6]\n\n\n\n\n\n\nschubert_class(schubert::AbstractGKM_graph, BO::BruhatOrder, v::Int64)\n\nLike above, but the Weyl group element is given by the index v corresponding to its index as vertex of the GKM graph on the flag variety containing the Schubert variety.\n\n\n\n\n\nschubert_class(flag::AbstractGKM_graph, BO::BruhatOrder, label::String)\n\nReturn the Poincare dual (as subvariety of the generalized partial flag variety flag) of the Schubert variety determined by label.\n\nArguments\n\nflag::AbstractGKM_graph: The generalized partial flag variety (as returned by generalized_gkm_flag).\nBO::BruhatOrder: The Bruhat order on the generalized partial flag variety (as returned by get_bruhat_order_of_generalized_flag).\nlabel:String: The label of the Weyl group element or coset defining the Schubert variety as subvariety of the generalized partial flag variety.\n\nExample\n\njulia> R = root_system(:G, 2);\n\njulia> BO = get_bruhat_order_of_generalized_flag(R);\n\njulia> flag = generalized_gkm_flag(R);\n\njulia> schubert_class(flag, BO, \"s2*s1*s2*s1*s2\")\n(-t2 + t3)*e[1] + (-t1 - t2 + 2*t3)*e[2] + (t1 - 2*t2 + t3)*e[3] + (-t1 + t3)*e[4] + (t1 - t2)*e[5] + (-t2 + t3)*e[7] + (-t1 - t2 + 2*t3)*e[8] + (t1 - 2*t2 + t3)*e[9] + (-t1 + t3)*e[10] + (t1 - t2)*e[11]\n\n\n\n\n\n\nschubert_class(flag::AbstractGKM_graph, BO::BruhatOrder, v::Int64)\n\nLike above, but the Weyl group element is given by the index v corresponding to its index as vertex of the GKM graph on the Schubert variety.\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Oscar.IntersectionTheory.schubert_classes","page":"Standard Constructions","title":"Oscar.IntersectionTheory.schubert_classes","text":"schubert_classes(schubert::AbstractGKM_subgraph, BO::BruhatOrder)\n\nReturn all Schubert classes on the given generalized Schubert variety. The i-th row in the returned matrix is the Schubert class of the Weyl group element (or coset) corresponding to the i-th vertex of the given Schubert variety.\n\nArguments\n\nschubert::AbstractGKM_subgraph: The Schubert variety given as GKM subgraph of its generalized partial flag variety (as returned by generalized_gkm_schubert).\nBO::BruhatOrder: The Bruhat order for the generalized partial flag variety containing the Schubert variety (as returned by get_bruhat_order_of_generalized_flag).\n\nExamples\n\nSchubert classes on the Schubert variety overlineX_s_1s_2s_3subset SL_4P_1:\n\njulia> R = root_system(:A, 2);\n\njulia> S = simple_roots(R);\n\njulia> schubert = generalized_gkm_schubert(R, S[1:1], \"s1*s2\");\n\njulia> BO = get_bruhat_order_of_generalized_flag(R, S[1:1]);\n\njulia> schubert_classes(schubert, BO)\n3×3 Matrix{QQMPolyRingElem}:\n t1*t2 - t1*t3 - t2*t3 + t3^2  0        0\n t1 - t3                       t1 - t2  0\n 1                             1        1\n\n\n\n\n\nschubert_classes(flag::AbstractGKM_graph, BO::BruhatOrder)\n\nReturn all Schubert classes on the given generalized partial flag variety. The i-th row in the returned matrix is the Schubert class of the Weyl group element (or coset) corresponding to the i-th vertex of the given partial flag variety.\n\nArguments\n\nflag::AbstractGKM_graph: The generalized partial flag variety (as returned by generalized_gkm_flag).\nBO::BruhatOrder: The Bruhat order for the generalized partial flag variety containing the Schubert variety (as returned by get_bruhat_order_of_generalized_flag).\n\nExample\n\njulia> R = root_system(:A, 2);\n\njulia> BO = get_bruhat_order_of_generalized_flag(R);\n\njulia> flag = generalized_gkm_flag(R);\n\njulia> schubert_classes(flag, BO)\n6×6 Matrix{QQMPolyRingElem}:\n t1^2*t2 - t1^2*t3 - t1*t2^2 + t1*t3^2 + t2^2*t3 - t2*t3^2  0                             0        0  0                             0\n t1*t2 - t1*t3 - t2*t3 + t3^2                               t1*t2 - t1*t3 - t2*t3 + t3^2  0        0  0                             0\n t1 - t3                                                    t1 - t3                       t1 - t2  0  t1 - t2                       0\n 1                                                          1                             1        1  1                             1\n t1^2 - t1*t2 - t1*t3 + t2*t3                               0                             0        0  t1^2 - t1*t2 - t1*t3 + t2*t3  0\n t1 - t3                                                    t2 - t3                       0        0  t1 - t3                       t2 - t3\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Toric-varieties","page":"Standard Constructions","title":"Toric varieties","text":"","category":"section"},{"location":"GKM/STDconstructions/#GKMtools.gkm_graph_of_toric","page":"Standard Constructions","title":"GKMtools.gkm_graph_of_toric","text":"gkm_graph_of_toric(v::NormalToricVariety) -> AbstractGKM_graph{ZZRingElem}\n\nConstruct the GKM graph of the (smooth, projective) toric variety v.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> gkm_graph_of_toric(P2)\nGKM graph with 3 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1)\n3 -> 1 => (0, 1, -1)\n3 -> 2 => (-1, 1, 0)\n\njulia> F = hirzebruch_surface(NormalToricVariety, 3)\nNormal toric variety\n\njulia> gkm_graph_of_toric(F)\nGKM graph with 4 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1, 0)\n3 -> 2 => (3, 1, 0, -1)\n4 -> 1 => (0, 1, 3, -1)\n4 -> 3 => (-1, 0, 1, 0)\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#Quantum-Cohomology","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"","category":"section"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"Much of this can be found in [CK99, Chapter 8 and 9.3]. Let X be a (smooth projective) GKM variety. Its (small) equivariant quantum cohomology QH_T^*(X) is given additively by H_T^*(XmathbbQ)otimes widehatmathbbQH_2^texteff(XmathbbZ), where widehatmathbbQH_2^texteff(XmathbbZ) is the completion of the semigroup ring H_2^texteff(XmathbbZ) of effective curve classes. The element corresponding to betain H_2^texteff(XmathbbZ) is written as q^beta.","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"The H_T(textptmathbbQ)-module QH_T^*(X) is a commutative associative unital H_T(textptmathbbQ)-algebra via the (small) equivariant quantum product ast defined as follows. For every classes abcin H_T^*(XmathbbQ) we have","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"  langle a ast b c rangle = sum_betain H_2^texteff(XmathbbZ) GW^T_03beta(abc) cdot q^beta","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"where:","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"The equivariant Poincaré pairing is given by langle abrangle = int_X acup bin H_T^*(textptmathbbQ), where we use equivariant integration,\nWe denote by GW^T_03beta(abc)in H_T^*(textptmathbbQ) the equivariant Gromov–Witten invariant for X in class beta of genus 0 with 3 marked points.","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"Note that setting all the equivariant parameters t_1dotst_dim_mathbbC(T) to zero recovers the standard (small, non-equivariant) quantum product.","category":"page"},{"location":"GW/QH/#Structure-Constants","page":"Quantum Cohomology","title":"Structure Constants","text":"","category":"section"},{"location":"GW/QH/#GKMtools.QH_structure_constants","page":"Quantum Cohomology","title":"GKMtools.QH_structure_constants","text":"QH_structure_constants(G::AbstractGKM_graph; refresh::Bool=false)\n\nReturn the structure constants of the equivariant quantum cohomology QH_T^*(X) where X is the GKM variety realizing the GKM graph.\n\nwarning: Warning\nThis requires is_strictly_nef(G)==true, as this guarantees that there are at most finitely many curve classes beta with non-zero coefficients for q^beta.\nIf is_strictly_nef(G)==false, use the method of QH_structure_constants below that specifies a specific beta.\n\nnote: Note\nAs this computation might be expensive, the result is stored in G for later use. If the requested structure constants have been computed before, they will not be computed afresh unless the optional argument refresh is set to true.\n\nOutput format:\n\nThe output type is Dict{CurveClass_type, Array{Any, 3}}. If ans denotes the returned object, then ans[beta][i, j, k] is the the q^beta-coefficient of PD(v_i) ast PD(v_j) localized at v_k, where v_i v_j v_k represent the fixed points with indices ijk, respectively,  and PD represents the Poincaré dual.\n\nOptional arguments:\n\nrefresh::Bool: false by default. If true, then this will overwrite any previously calculated QH_T structure constants of G.\n\nExample\n\njulia> P1 = projective_space(GKM_graph, 1);\n\njulia> S = QH_structure_constants(P1; show_progress=false)\nDict{AbstractAlgebra.FPModuleElem{ZZRingElem}, Array{Any, 3}} with 2 entries:\n  (0) => [t1^2 - 2*t1*t2 + t2^2 0; 0 0;;; 0 0; 0 t1^2 - 2*t1*t2 + t2^2]\n  (1) => [1 1; 1 1;;; 1 1; 1 1]\n\n\n\n\n\nQH_structure_constants(G::AbstractGKM_graph, beta::CurveClass_type; refresh::Bool=false, P_input=nothing, show_progress::Bool=true)\n\nReturn the q^beta-coefficients of the structure constants of the equivariant quantum cohomology QH_T^*(X), where X is the GKM variety realizing the GKM graph.\n\nnote: Note\nAs this computation might be expensive, the result is stored in G for later use. If the requested structure constants have been computed before, they will not be computed afresh unless the optional argument refresh is set to true.\n\nOutput format:\n\nThe output type is Array{Any, 3}. Ifans denotes the returned object, then ans[i, j, k] is the the q^beta-coefficient of PD(v_i) ast PD(v_j) localized at v_k, where v_i v_j v_k represent the fixed points with indices ijk, respectively,  and PD represents the Poincaré dual.\n\nOptional arguments:\n\nrefresh::Bool: false by default. If true, then this will overwrite any previously calculated QH_T structure constants of G.\n\nExample\n\njulia> P1 = projective_space(GKM_graph, 1);\n\njulia> beta = curve_class(P1, Edge(1, 2));\n\njulia> QH_structure_constants(P1, 0*beta; show_progress=false)\n2×2×2 Array{AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}, 3}:\n[:, :, 1] =\n t1^2 - 2*t1*t2 + t2^2  0\n 0                      0\n\n[:, :, 2] =\n 0  0\n 0  t1^2 - 2*t1*t2 + t2^2\n\njulia> QH_structure_constants(P1, beta; show_progress=false)\n2×2×2 Array{AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}, 3}:\n[:, :, 1] =\n 1  1\n 1  1\n\n[:, :, 2] =\n 1  1\n 1  1\n\njulia> QH_structure_constants(P1, 2*beta; show_progress=false)\n2×2×2 Array{AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}, 3}:\n[:, :, 1] =\n 0  0\n 0  0\n\n[:, :, 2] =\n 0  0\n 0  0\n\njulia> QH_structure_constants(P1, -1 * beta; show_progress=false)\n2×2×2 Array{AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}, 3}:\n[:, :, 1] =\n 0  0\n 0  0\n\n[:, :, 2] =\n 0  0\n 0  0\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#GKMtools.QH_structure_constants_in_basis","page":"Quantum Cohomology","title":"GKMtools.QH_structure_constants_in_basis","text":"QH_structure_constants_in_basis(G::AbstractGKM_graph, b::Matrix; setPreferredBasis::Bool=false)\n\nReturn all structure constants of G that have been calculated so far with respect to the given basis. A smart choice of basis can drastically simplify the presentation of the ring QH_T^*(X).\n\nnote: Note\nThis does not calculate any structure constants afresh. To do so, use QH_structure_constants.\nThis will omit any curve classes in which all structure constants are zero.\n\nOutput format:\n\nThe same as that of QH_structure_constants, i.e. of type Dict{CurveClass_type, Array{Any, 3}}.\n\nArguments\n\nG::AbstractGKM_graph: The GKM graph whose quantum cohomology is of interest.\nb::Matrix: A matrix whose rows are the desired H_T^*(textptmathbbQ)-linear basis of H_T^*(XmathbbQ).  The element b[i,j] is the localization to the j-th fixed point of the i-th basis element.\nsetPreferredBasis::Bool=false: Optional argument. If set to true, all future quantum cohomology classes of this space  will be printed with respect to the given base.\n\nExamples\n\nThe following example shows that QH_T(XmathbbQ) congmathbbQt_1 t_2 e(e^2 - (t_1-t_2)e - q) where e=PD(10) and q corresponds to the curve class mathbbP^1in H_2(mathbbP^1mathbbZ).\n\njulia> P1 = projective_space(GKM_graph, 1);\n\njulia> QH_structure_constants(P1; show_progress=false);\n\njulia> P1 = projective_space(GKM_graph, 1);\n\njulia> QH_structure_constants(P1; show_progress=false)\nDict{AbstractAlgebra.FPModuleElem{ZZRingElem}, Array{Any, 3}} with 2 entries:\n  (0) => [t1^2 - 2*t1*t2 + t2^2 0; 0 0;;; 0 0; 0 t1^2 - 2*t1*t2 + t2^2]\n  (1) => [1 1; 1 1;;; 1 1; 1 1]\n\njulia> t1, t2 = gens(P1.equivariantCohomology.coeffRing);\n\njulia> base = [1 1; t1-t2 0 ];\n\njulia> QH_structure_constants_in_basis(P1, base)\nDict{AbstractAlgebra.FPModuleElem{ZZRingElem}, Array{Any, 3}} with 2 entries:\n  (0) => [1 0; 0 0;;; 0 1; 1 t1 - t2]\n  (1) => [0 0; 0 1;;; 0 0; 0 0]\n\nSimilarly, choosing a nice basis simplifies the presentation of QH_T(mathbbP^2). By the below, it is isomorphic as H_T^*(textptmathbbQ)-algebra to mathbbQt_1t_2t_3 e 1(e(e-t_1+t_2)(e-t_1+t_3) - q),  where e = PD(mathbbP^1_xy0).\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> QH_structure_constants(P2; show_progress=false); # Calculate all relevant structure constants.\n\njulia> (t1, t2, t3) = gens(P2.equivariantCohomology.coeffRing);\n\njulia> base = [1 1 1; t1-t3 t2-t3 0 ; (t1-t2)*(t1-t3) 0 0];\n\njulia> S = QH_structure_constants_in_basis(P2, base)\nDict{AbstractAlgebra.FPModuleElem{ZZRingElem}, Array{Any, 3}} with 2 entries:\n  (0) => [1 0 0; 0 0 0; 0 0 0;;; 0 1 0; 1 t2 - t3 0; 0 0 0;;; 0 0 1; 0 1 t1 - t3; 1 t1 - t3 t1^2 - t1*t2 - t1*t3 + t2*t3]\n  (1) => [0 0 0; 0 0 1; 0 1 t1 - t2;;; 0 0 0; 0 0 0; 0 0 1;;; 0 0 0; 0 0 0; 0 0 0]\n\njulia> beta = curve_class(P2, Edge(1, 2));\n\njulia> S[beta][:,:,1]\n3×3 Matrix{Any}:\n 0  0  0\n 0  0  1\n 0  1  t1 - t2\n\njulia> S[beta][:,:,2]\n3×3 Matrix{Any}:\n 0  0  0\n 0  0  0\n 0  0  1\n\njulia> S[beta][:,:,3]\n3×3 Matrix{Any}:\n 0  0  0\n 0  0  0\n 0  0  0\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#GKMtools.QH_supporting_curve_classes","page":"Quantum Cohomology","title":"GKMtools.QH_supporting_curve_classes","text":"QH_supporting_curve_classes(G::AbstractGKM_graph)\n\nReturn a list of all curve classes of G in which a non-zero structure constant for the equivariant quantum product has been calculated.\n\nnote: Note\nThis does not calculate any structure constants afresh but works with all constants calculated so far. To calculate them, use QH_structure_constants (see above).\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#Quantum-Arithmetic","page":"Quantum Cohomology","title":"Quantum Arithmetic","text":"","category":"section"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"Equivariant cohomology classes in X can be turned into QHRingElem. The standard arithmetic operations +, *, etc. are supported, where * denotes the equivariant quantum product in QH_T^*(X).","category":"page"},{"location":"GW/QH/#GKMtools.QH_class","page":"Quantum Cohomology","title":"GKMtools.QH_class","text":"QH_class(G::AbstractGKM_graph, class; beta::Union{Nothing, CurveClass_type} = nothing)\n\nTurn the given equivariant cohomology class class into an equivariant quantum cohomology class on G. The optional argument beta can be used to multiply the result by the coefficient q^beta for a curve class beta.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> QH_class(P2, point_class(P2, 1))\n(t1^2 - t1*t2 - t1*t3 + t2*t3, 0, 0) q^(0)\n\njulia> QH_class(P2, point_class(P2, 1); beta = curve_class(P2, Edge(1, 2)))\n(t1^2 - t1*t2 - t1*t3 + t2*t3, 0, 0) q^(1)\n\njulia> (t1, t2, t3) = gens(P2.equivariantCohomology.coeffRing); # hyperplane class\n\njulia> QH_class(P2, [t1, t2, t3])\n(t1, t2, t3) q^(0)\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#Base.:*-Tuple{GKMtools.QHRingElem, GKMtools.QHRingElem}","page":"Quantum Cohomology","title":"Base.:*","text":"*(c1::QHRingElem, c2::QHRingElem) -> QHRingElem\n\nMultiply the classes c1 and c2 using the equivariant quantum product in QH_T^*(X).\n\nwarning: Warning\nThis requires is_strictly_nef(G)==true for the underlying GKM graph G. If this does not hold, there could potentially be infinitely many beta contributing a non-zero q^beta-term to the quantum product. In this case, use quantum_product to calculate the coefficient of q^beta in the quantum product for a specified choice of beta.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> (t1, t2, t3) = gens(P2.equivariantCohomology.coeffRing);\n\njulia> H = QH_class(P2, [t1, t2, t3]) # The equivariant hyperplane class as element of QH_T(X)\n(t1, t2, t3) q^(0)\n\njulia> (H - t1) * (H - t2) * (H - t3)\n(1, 1, 1) q^(1)\n\njulia> p = QH_class(P2, point_class(P2, 1))\n(t1^2 - t1*t2 - t1*t3 + t2*t3, 0, 0) q^(0)\n\njulia> p * H\n(t1^3 - t1^2*t2 - t1^2*t3 + t1*t2*t3, 0, 0) q^(0)\n + (1, 1, 1) q^(1)\n\n\n\n\n\n","category":"method"},{"location":"GW/QH/#GKMtools.quantum_product","page":"Quantum Cohomology","title":"GKMtools.quantum_product","text":"quantum_product(G::AbstractGKM_graph, beta::CurveClass_type, class1, class2; useStructureConstants::Bool = true)\n\nCalculate the q^beta-coefficient of the equivariant quantum product of the equivariant cohomology classes class1 and class2 on G. This does not require\n\nIf the optional argument useStructureConstants is set to false, then this will always calculate the relevant Gromov–Witten invariants freshly using gromov_witten, even if they have been calculated before.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> beta = curve_class(P2, Edge(1, 2));\n\njulia> quantum_product(P2, beta, point_class(P2, 1), point_class(P2, 2))\n(t1 - t3, t2 - t3, 0)\n\njulia> quantum_product(P2, 0*beta, point_class(P2, 1), point_class(P2, 2))\n(0, 0, 0)\n\njulia> quantum_product(P2, 2*beta, point_class(P2, 1), point_class(P2, 2))\n(0, 0, 0)\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#GKMtools.quantum_product_at_q1","page":"Quantum Cohomology","title":"GKMtools.quantum_product_at_q1","text":"quantum_product_at_q1(G::AbstractGKM_graph, class)\n\nReturn the matrix of equivariant quantum multiplication on G by the class class after setting q=1.\n\nnote: Note\nThis matrix is in the basis (1 0 dots 0) (0 1 0dots 0) dots (0d0ts01) of H_T^*(XmathbbQ) localized at the  fraction field of the coefficient ring. These classes do not represent classes in H_T^*(XmathbbQ) without localizing the coefficient ring, so in particular the output will consist of rational functions even when G is the GKM graph of a (smooth projective) GKM variety.\n\nwarning: Warning\nThis requires is_strictly_nef(G)==true as otherwise the quantum product might have infinitely many summands, so setting q=1 is not well-defined.\n\nExample\n\njulia> P1 = projective_space(GKM_graph, 1);\n\njulia> quantum_product_at_q1(P1, point_class(P1, 1))\n[(t1^2 - 2*t1*t2 + t2^2 + 1)//(t1 - t2)    1//(t1 - t2)]\n[                         -1//(t1 - t2)   -1//(t1 - t2)]\n\njulia> (t1, t2) = gens(P1.equivariantCohomology.coeffRing);\n\njulia> quantum_product_at_q1(P1, [t1, t2])\n[(t1^2 - t1*t2 + 1)//(t1 - t2)                    1//(t1 - t2)]\n[                -1//(t1 - t2)   (t1*t2 - t2^2 - 1)//(t1 - t2)]\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#Quantum-product-with-c_1T(TX)","page":"Quantum Cohomology","title":"Quantum product with c_1^T(TX)","text":"","category":"section"},{"location":"GW/QH/#GKMtools.c1_at_q1","page":"Quantum Cohomology","title":"GKMtools.c1_at_q1","text":"c1_at_q1(G::AbstractGKM_graph)\n\nThe same as quantum_product_at_q1(G, first_chern_class(G)) (see above).\n\nExample\n\njulia> c1_at_q1(projective_space(GKM_graph, 1))\n[(t1^2 - 2*t1*t2 + t2^2 + 2)//(t1 - t2)                              2//(t1 - t2)]\n[                         -2//(t1 - t2)   (-t1^2 + 2*t1*t2 - t2^2 - 2)//(t1 - t2)]\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#GKMtools.conjecture_O_eigenvalues","page":"Quantum Cohomology","title":"GKMtools.conjecture_O_eigenvalues","text":"conjecture_O_eigenvalues(G::AbstractGKM_graph; printData::Bool=true)\n\nReturn the eigenvalues of quantum multiplication by c_1^T(TX), the equivariant first Chern class of the tangent bundle at q=1 t=0, where t are the equivariant parameters.\n\nwarning: Warning\nThis requires is_strictly_nef(G)==true as otherwise the quantum product might have infinitely many summands, so setting q=1 is not well-defined.\n\nExample\n\njulia> c1_at_q1(projective_space(GKM_graph, 1))\n[(t1^2 - 2*t1*t2 + t2^2 + 2)//(t1 - t2)                              2//(t1 - t2)]\n[                         -2//(t1 - t2)   (-t1^2 + 2*t1*t2 - t2^2 - 2)//(t1 - t2)]\n\njulia> conjecture_O_eigenvalues(projective_space(GKM_graph, 1))\nCharacteristic poly of c1(TX)* at q=1, t=0:\nx^2 - 4\n2-element Vector{QQBarFieldElem}:\n Root 2.00000 of x - 2\n Root -2.00000 of x + 2\n\njulia> conjecture_O_eigenvalues(projective_space(GKM_graph, 2))\nCharacteristic poly of c1(TX)* at q=1, t=0:\nx^3 - 27\n3-element Vector{QQBarFieldElem}:\n Root 3.00000 of x - 3\n Root -1.50000 + 2.59808*im of x^2 + 3x + 9\n Root -1.50000 - 2.59808*im of x^2 + 3x + 9\n\njulia> conjecture_O_eigenvalues(projective_space(GKM_graph, 3))\nCharacteristic poly of c1(TX)* at q=1, t=0:\nx^4 - 256\n4-element Vector{QQBarFieldElem}:\n Root 4.00000 of x - 4\n Root -4.00000 of x + 4\n Root 4.00000*im of x^2 + 16\n Root -4.00000*im of x^2 + 16\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#Sanity-checks","page":"Quantum Cohomology","title":"Sanity checks","text":"","category":"section"},{"location":"GW/QH/#GKMtools.QH_is_commutative","page":"Quantum Cohomology","title":"GKMtools.QH_is_commutative","text":"QH_is_commutative(G::AbstractGKM_graph) -> Bool\n\nReturn whether the calculated structure constants of QH_T^*(X) are commutative. If G is the GKM graph of a (smooth projective) GKM variety, then this should always return true.\n\nwarning: Warning\nThis requires is_strictly_nef(G)==true as otherwise there might be infinitely many structure constants to check.\n\nExample\n\njulia> P3 = projective_space(GKM_graph, 3);\n\njulia> QH_is_commutative(P3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#GKMtools.QH_is_associative","page":"Quantum Cohomology","title":"GKMtools.QH_is_associative","text":"QH_is_associative(G::AbstractGKM_graph; printDiagnostics::Bool) -> Bool\n\nReturn whether the calculated structure constants of QH_T^*(X) are associative. If G is the GKM graph of a (smooth projective) GKM variety, then this should always return true.\n\nwarning: Warning\nThis requires is_strictly_nef(G)==true as otherwise there might be infinitely many structure constants to check.\n\nOptional arguments\n\nprintDiagnostics::Bool: If this is true and the function's output is false, then the indices where associativity fails are printed.\n\nExample\n\njulia> P3 = projective_space(GKM_graph, 3);\n\njulia> QH_is_associative(P3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#GKMtools.QH_is_homogeneous","page":"Quantum Cohomology","title":"GKMtools.QH_is_homogeneous","text":"QH_is_homogeneous(G::AbstractGKM_graph) -> Bool\n\nReturn whether all structure constants of the equivariant quantum product of G calculated so far are homogeneous.\n\nnote: Note\nThis does not calculate any structure constants afresh but checks all constants calculated so far. To calculate them, use QH_structure_constants (see above).\n\nExample\n\njulia> P3 = projective_space(GKM_graph, 3);\n\njulia> QH_structure_constants(P3; show_progress=false);\n\njulia> QH_is_homogeneous(P3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#GKMtools.QH_is_polynomial","page":"Quantum Cohomology","title":"GKMtools.QH_is_polynomial","text":"QH_is_polynomial(G::AbstractGKM_graph) -> Bool\n\nReturn whether all structure constants of the equivariant quantum product of G calculated so far are polynomial (rather than fractions of polynomials).\n\nnote: Note\nThis does not calculate any structure constants afresh but checks all constants calculated so far. To calculate them, use QH_structure_constants (see above).\n\nExample\n\njulia> P3 = projective_space(GKM_graph, 3);\n\njulia> QH_structure_constants(P3; show_progress=false);\n\njulia> QH_is_polynomial(P3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"GKM/Connections/#Connections","page":"Connections","title":"Connections","text":"","category":"section"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"Let e be an directed edge prightarrow q, and let E_p (resp., E_q) be the set of all directed edges starting from p (resp., q). Following [GZ00], a connection along e is a bijection","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"nabla_ecolon E_p longrightarrow E_q","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"A connection nabla of a GKM graph G is a family of connections nabla = nabla_e _e in E, where E is the set of all edges of G, such that nabla_-e=nabla_e^-1.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"The connection is compatible with the axial function mathrmw of G if for all e in E_p, there exists an integer a depending on e and e such that","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"mathrmw(nabla_e(e)) = mathrmw(e) - a mathrmw(e)","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"If G is the GKM graph of a GKM variety X, then these integers a are the degrees of the equivariant line bundles into which TX splits when restricted to the invariant rational curve represented by e.","category":"page"},{"location":"GKM/Connections/#Existence-and-uniqueness-of-connections","page":"Connections","title":"Existence and uniqueness of connections","text":"","category":"section"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"Given a GKM graph G that comes from a GKM variety X, it always has a connection for the geometric reason sketched above. However, G may admit more than one connection.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"The following are sufficient conditions for the existence of a unique connection of G.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"The valency of G is at least 3 and G is 3-independent, i.e. the weights of every three edges starting at the same vertex are linearly independent.\nThe valency of G is at most 2.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"In those cases, the connection can be computed using get_connection.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"If neither of these two conditions hold and G is not the output of a standard construction, a choice of connection can be specified manually using set_connection!.","category":"page"},{"location":"GKM/Connections/#GKMtools.get_connection-Tuple{GKMtools.AbstractGKM_graph}","page":"Connections","title":"GKMtools.get_connection","text":"get_connection(gkm::AbstractGKM_graph) -> Union{Nothing, GKM_connection}\n\nReturn the connection of the given GKM graph if it is 3-independent, or if it is 2-valent and 2-independent,  or if it has been set manually. If one of the first two cases holds and the connection hasn't been calculated before, it is saved in the gkm object for later use. If none of the three cases hold, return nothing.\n\nnote: Note\nFor GKM graphs of valency at least 3 that are not 3-independent, a connection may still exist, although uniqueness is not guaranteed. Use get_any_connection to get any compatible connection if one exists.\n\nExample\n\nThe unique connection for mathbbP^n has nabla_(prightarrow q)(prightarrow r)=(qrightarrow r) for every triple of distinct vertices (p q r), and nabla_(prightarrow q)(prightarrow q)=(qrightarrow p) for every distinct vertices p and q.\n\njulia> G = projective_space(GKM_graph, 2)\nGKM graph with 3 nodes, valency 2 and axial function:\n2 -> 1 => (-1, 1, 0)\n3 -> 1 => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\n\njulia> C = get_connection(G)\nGKM connection for GKM graph with 3 nodes and valency 2:\nConnection:\n(Edge(3, 2), Edge(3, 1)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 3)) => Edge(1, 3)\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(3, 2), Edge(3, 2)) => Edge(2, 3)\n(Edge(1, 3), Edge(1, 2)) => Edge(3, 2)\n(Edge(2, 3), Edge(2, 1)) => Edge(3, 1)\n(Edge(1, 3), Edge(1, 3)) => Edge(3, 1)\n(Edge(1, 2), Edge(1, 3)) => Edge(2, 3)\n(Edge(3, 1), Edge(3, 2)) => Edge(1, 2)\n(Edge(3, 1), Edge(3, 1)) => Edge(1, 3)\n(Edge(2, 3), Edge(2, 3)) => Edge(3, 2)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(3, 2), Edge(3, 1)) => 1\n(Edge(2, 1), Edge(2, 3)) => 1\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(3, 2), Edge(3, 2)) => 2\n(Edge(1, 3), Edge(1, 2)) => 1\n(Edge(2, 3), Edge(2, 1)) => 1\n(Edge(1, 3), Edge(1, 3)) => 2\n(Edge(1, 2), Edge(1, 3)) => 1\n(Edge(3, 1), Edge(3, 2)) => 1\n(Edge(3, 1), Edge(3, 1)) => 2\n(Edge(2, 3), Edge(2, 3)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\n\n\n\n\n","category":"method"},{"location":"GKM/Connections/#GKMtools.get_any_connection-Tuple{GKMtools.AbstractGKM_graph}","page":"Connections","title":"GKMtools.get_any_connection","text":"get_any_connection(gkm::AbstractGKM_graph)::Union{Nothing, GKM_connection}\n\nReturn any connection for the given GKM graph, if there exists one, or nothing otherwise. This connection is not guaranteed to have any special properties. In particular, if gkm is the GKM graph of a sufficiently nice space, the returned connection is not guaranteed to be the one induced by the geometry of the space.\n\n\n\n\n\n","category":"method"},{"location":"GKM/Connections/#GKMtools.build_GKM_connection","page":"Connections","title":"GKMtools.build_GKM_connection","text":"build_GKM_connection(gkm::AbstractGKM_graph, con::Dict{Tuple{Edge, Edge}, Edge}) -> GKM_connection\n\nReturn the GKM_connection object (including information of the integers a) defined by the given connection map.\n\nwarning: Warning\nThis function does not check whether the given connection map is valid (use isvalid(::GKM_connection) for that).\nThis does not save the new connection to the gkm object (use set_connection!(::AbstractGKM_graph, ::GKM_connection) for that).\n\nExample\n\njulia> G = projective_space(GKM_graph, 1)\nGKM graph with 2 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1)\n\njulia> con = Dict{Tuple{Edge, Edge}, Edge}()\nDict{Tuple{Edge, Edge}, Edge}()\n\njulia> con[(Edge(1, 2), Edge(1, 2))] = Edge(2, 1)\nEdge(2, 1)\n\njulia> con[(Edge(2, 1), Edge(2, 1))] = Edge(1, 2)\nEdge(1, 2)\n\njulia> C = build_GKM_connection(G, con)\nGKM connection for GKM graph with 2 nodes and valency 1:\nConnection:\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\nnote: Note\nIn this example, it is unnecessary to define the connection manually, since there is a unique one. To get it, simply use get_connection(G).\n\n\n\n\n\nbuild_GKM_connection(gkm::AbstractGKM_graph, a::Dict{Tuple{Edge, Edge}, ZZRingElem}) -> GKM_connection\n\nReturn the GKM_connection object (including the connection map nabla) defined by the given integers a.\n\nwarning: Warning\nThis function does not check whether the given connection map is valid (use isvalid(::GKM_connection) for that).\nThis does not save the new connection to the gkm object (use set_connection!(::AbstractGKM_graph, ::GKM_connection) for that).\n\nExample\n\njulia> G = projective_space(GKM_graph, 1)\nGKM graph with 2 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1)\n\njulia> a = Dict{Tuple{Edge, Edge}, ZZRingElem}()\nDict{Tuple{Edge, Edge}, ZZRingElem}()\n\njulia> a[(Edge(1, 2), Edge(1, 2))] = 2\n2\n\njulia> a[(Edge(2, 1), Edge(2, 1))] = 2\n2\n\njulia> C = build_GKM_connection(G, a)\nGKM connection for GKM graph with 2 nodes and valency 1:\nConnection:\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\nnote: Note\nIn this example, it is unnecessary to define the connection manually, since there is a unique one. To get it, simply use get_connection(G).\n\n\n\n\n\n","category":"function"},{"location":"GKM/Connections/#GKMtools.set_connection!","page":"Connections","title":"GKMtools.set_connection!","text":"set_connection!(gkm::AbstractGKM_graph, con::GKM_connection)\n\nManually set the GKM connection of gkm to con. This will overwrite any previously set connection.\n\nExample\n\nAfter building the GKM_connection using build_GKM_connection like in the example above, we may assign it to the GKM graph using set_connection!:\n\njulia> G = projective_space(GKM_graph, 1);\n\njulia> a = Dict{Tuple{Edge, Edge}, ZZRingElem}();\n\njulia> a[(Edge(1, 2), Edge(1, 2))] = 2;\n\njulia> a[(Edge(2, 1), Edge(2, 1))] = 2;\n\njulia> C = build_GKM_connection(G, a);\n\njulia> set_connection!(G, C)\nGKM connection for GKM graph with 2 nodes and valency 1:\nConnection:\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\nnote: Note\nIn this example, it is unnecessary to set the connection manually, since there is a unique one. To get it, simply use get_connection(G).\n\n\n\n\n\n","category":"function"},{"location":"GKM/Connections/#Base.isvalid-Tuple{GKMtools.GKM_connection}","page":"Connections","title":"Base.isvalid","text":"isvalid(con::GKM_connection; printDiagnostics::Bool=true) -> Bool\n\nReturn true if the given connection is valid for its GKM graph. This holds if and only if all of the following hold:\n\ncon.con and con.a are set for all (Edge(v,w), Edge(v,u)) where vw and vu are edges in the graph\ncon maps every (e,e) to reverse(e)\na maps every (e,e) to 2\nEvery pair of edges (e,ei) with same source satisfies the relation of the associated a's (see above), i.e. con.gkm.w[ei'] = con.gkm.w[ei] - con.a[(e,ei)] * con.gkm.w[e]\n\nExample\n\njulia> G = projective_space(GKM_graph, 1);\n\njulia> C = get_connection(G)\nGKM connection for GKM graph with 2 nodes and valency 1:\nConnection:\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\njulia> C.con[(Edge(1, 2), Edge(1, 2))] = Edge(1, 2) # Should be Edge(2, 1)!\nEdge(1, 2)\n\njulia> isvalid(C)\nConnection doesn't map (e,e) to reverse(e) for e=Edge(1, 2).\nfalse\n\n\n\n\n\n","category":"method"},{"location":"GKM/Connections/#GKMtools.is_compatible_with_connection","page":"Connections","title":"GKMtools.is_compatible_with_connection","text":"is_compatible_with_connection(gkmSub::AbstractGKM_subgraph, con::GKM_connection; printDiagnostics::Bool=true)::Bool\n\nReturn true if the connection map sends edge pairs contained in the subgraph to an edge of the subgraph. This is necessary for the subgraph to represent a T-invariant subspace.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Vectorbundles/#Vector-Bundles","page":"Vector Bundles","title":"Vector Bundles","text":"","category":"section"},{"location":"GKM/Vectorbundles/","page":"Vector Bundles","title":"Vector Bundles","text":"Theory of GKM vector bundles, see [GSZ12].","category":"page"},{"location":"GKM/Vectorbundles/#Oscar.IntersectionTheory.line_bundle","page":"Vector Bundles","title":"Oscar.IntersectionTheory.line_bundle","text":"line_bundle(G::AbstractGKM_graph, M::AbstractAlgebra.Generic.FreeModule{R}, GMtoM::AbstractAlgebra.Generic.ModuleHomomorphism{R}, weights::Vector{AbstractAlgebra.Generic.FreeModuleElem{R}}) -> GKM_vector_bundle\n\nReturn the equivariant line bundle over the GKM graph G whose weights over the fixed points are given by weights.\n\nArguments\n\ng::G::AbstractGKM_graph: A GKM graph\nM::AbstractAlgebra.Generic.FreeModule{R}: The weight lattice of the torus acting on the line bundle.   This is often bigger than the torus acting on G, for example when there is an extra scaling-action on the fibres.\nGMtoM::AbstractAlgebra.Generic.ModuleHomomorphism{R}: The inclusion of G.M (the weight lattice of the torus acting on G) into M (the weight lattice of the possibly bigger torus acting on the total space of the line bundle).\nweights::Vector{AbstractAlgebra.Generic.FreeModuleElem{R}}: A vector containing the weight of the fibre of the line bundle over each vertex of G.\n\nExamples\n\nThe trivial line bundle Lrightarrow mathbbP^2 with scaling action on each fibre. Here T=(mathbbC^times)^3 acts on mathbbP^2 and TtimesmathbbC^times acts on the total space of L, where the  extra factor mathbbC^times scales each fiber and preserves the base.\n\njulia> G = projective_space(GKM_graph, 2);\n\njulia> M = free_module(ZZ, 4);\n\njulia> GMtoM = ModuleHomomorphism(G.M, M, [gens(M)[1], gens(M)[2], gens(M)[3]]);\n\njulia> V1 = line_bundle(G, M, GMtoM, [gens(M)[4], gens(M)[4], gens(M)[4]])\nGKM vector bundle of rank 1 over GKM graph with 3 nodes and valency 2 with weights:\n1: (0, 0, 0, 1)\n2: (0, 0, 0, 1)\n3: (0, 0, 0, 1)\n\nHere is another line bundle on mathbbP^2 with a more interesting action than fibrewise scaling:\n\njulia> V2 = line_bundle(G, M, GMtoM, [gens(M)[1], gens(M)[2], gens(M)[3]])\nGKM vector bundle of rank 1 over GKM graph with 3 nodes and valency 2 with weights:\n1: (1, 0, 0, 0)\n2: (0, 1, 0, 0)\n3: (0, 0, 1, 0)\n\n\n\n\n\n","category":"function"},{"location":"GKM/Vectorbundles/#GKMtools.vector_bundle","page":"Vector Bundles","title":"GKMtools.vector_bundle","text":"vector_bundle(G::AbstractGKM_graph, M::AbstractAlgebra.Generic.FreeModule{R}, GMtoM::AbstractAlgebra.Generic.ModuleHomomorphism{R}, weights::Matrix{AbstractAlgebra.Generic.FreeModuleElem{R}}; calculateConnection::Bool=true) -> GKM_vector_bundle\n\nConstruct the equivariant vector bundle given by the following datum:#\n\nArguments\n\ng::G::AbstractGKM_graph: The GKM graph of the base.\nM::AbstractAlgebra.Generic.FreeModule{R}: The weight lattice of the torus acting on the vector bundle.   This is often bigger than the torus acting on G, for example when there is an extra scaling-action on the fibres.\nGMtoM::AbstractAlgebra.Generic.ModuleHomomorphism{R}: The inclusion of G.M (the weight lattice of the torus acting on G) into M (the weight lattice of the possibly bigger torus acting on the total space of the vector bundle).\nweights::Matrix{AbstractAlgebra.Generic.FreeModuleElem{R}}: Over each fixed point (i.e., vertex of G), the vector bundle splits into a direct sum of r equivariant line bundles, where r is the rank of the vector bundle.   This argument is a matrix such that weights[i, j] is the j-th weight at the i-th vertex.\n\nExamples\n\nLet us construct manually (without using direct_sum()) the direct sum of the two examples from line_bundle().\n\njulia> G = projective_space(GKM_graph, 2);\n\njulia> M = free_module(ZZ, 4);\n\njulia> g = gens(M);\n\njulia> GMtoM = ModuleHomomorphism(G.M, M, [g[1], g[2], g[3]]);\n\njulia> V = vector_bundle(G, M, GMtoM, [g[1] g[4]; g[2] g[4]; g[3] g[4]])\nGKM vector bundle of rank 2 over GKM graph with 3 nodes and valency 2 with weights:\n1: (1, 0, 0, 0), (0, 0, 0, 1)\n2: (0, 1, 0, 0), (0, 0, 0, 1)\n3: (0, 0, 1, 0), (0, 0, 0, 1)\n\n\n\n\n\n","category":"function"},{"location":"GKM/Vectorbundles/#LinearAlgebra.rank-Tuple{GKMtools.GKM_vector_bundle}","page":"Vector Bundles","title":"LinearAlgebra.rank","text":"rank(V::GKM_vector_bundle) -> Int64\n\nReturn the rank of the given GKM vector bundle.\n\nExample\n\njulia> G = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 5));\n\njulia> M = free_module(ZZ, 5);\n\njulia> g = gens(M);\n\njulia> GMtoM = ModuleHomomorphism(G.M, M, [g[1], g[2], g[3], g[4]]);\n\njulia> L = line_bundle(G, M, GMtoM, [g[5], g[5], g[5], g[5]]);\n\njulia> rank(direct_sum(L, L, L))\n3\n\n\n\n\n\n","category":"method"},{"location":"GKM/Vectorbundles/#AbstractAlgebra.direct_sum","page":"Vector Bundles","title":"AbstractAlgebra.direct_sum","text":"direct_sum(V::GKM_vector_bundle{R}...) -> GKM_vector_bundle\n\nReturn the direct sum of the given vector bundles. This requires all bundles to have the same base GKM graph and the same character lattice.\n\nExample\n\njulia> G = projective_space(GKM_graph, 2);\n\njulia> M = free_module(ZZ, 4);\n\njulia> g = gens(M);\n\njulia> GMtoM = ModuleHomomorphism(G.M, M, [g[1], g[2], g[3]]);\n\njulia> V1 = line_bundle(G, M, GMtoM, [gens(M)[4], gens(M)[4], gens(M)[4]]);\n\njulia> V2 = line_bundle(G, M, GMtoM, [gens(M)[1], gens(M)[2], gens(M)[3]]);\n\njulia> V = direct_sum(V1, V2)\nGKM vector bundle of rank 2 over GKM graph with 3 nodes and valency 2 with weights:\n1: (0, 0, 0, 1), (1, 0, 0, 0)\n2: (0, 0, 0, 1), (0, 1, 0, 0)\n3: (0, 0, 0, 1), (0, 0, 1, 0)\n\n\n\n\n\n","category":"function"},{"location":"GKM/Vectorbundles/#Hecke.dual-Tuple{GKMtools.GKM_vector_bundle}","page":"Vector Bundles","title":"Hecke.dual","text":"dual(V::GKM_vector_bundle) -> GKM_vector_bundle\n\nReturn the dual equivariant vector bundle.\n\nExample\n\njulia> G = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 5));\n\njulia> M = free_module(ZZ, 5);\n\njulia> g = gens(M);\n\njulia> GMtoM = ModuleHomomorphism(G.M, M, [g[1], g[2], g[3], g[4]]);\n\njulia> L = line_bundle(G, M, GMtoM, [g[5], g[5], g[5], g[5]])\nGKM vector bundle of rank 1 over GKM graph with 4 nodes and valency 2 with weights:\n1: (0, 0, 0, 0, 1)\n2: (0, 0, 0, 0, 1)\n3: (0, 0, 0, 0, 1)\n4: (0, 0, 0, 0, 1)\n\njulia> dual(L)\nGKM vector bundle of rank 1 over GKM graph with 4 nodes and valency 2 with weights:\n1: (0, 0, 0, 0, -1)\n2: (0, 0, 0, 0, -1)\n3: (0, 0, 0, 0, -1)\n4: (0, 0, 0, 0, -1)\n\n\n\n\n\n\n","category":"method"},{"location":"GKM/Vectorbundles/#GKMtools.get_connection-Tuple{GKMtools.GKM_vector_bundle}","page":"Vector Bundles","title":"GKMtools.get_connection","text":"get_connection(V::GKM_vector_bundle)\n\nReturn the connection of the given vector bundle, if it is unique or has been set manually. If the vector bundle does not admit a unique connection and it has not bene set manually, return nothing.\n\nMathematical description:\n\nThis is the same concept as a Connection on a GKM graph. Let G be the GKM graph that is the basis of the vector bundle V. Assume that G comes from a GKM variety X. Then each edge of e corresponds to an invariant rational curve C_e in X. If V is an equivariant line bundle overe X, then its restriction to C_econgmathbbP^1 splits into a direct sum of equivariant line bundles. This defines a bijection between the direct summands of V at textsrc(e) and the direct summands of V at textdst(e).\n\nThis bijection is recorded in the returned object.\n\nExample\n\njulia> G = projective_space(GKM_graph, 2);\n\njulia> M = free_module(ZZ, 4);\n\njulia> g = gens(M);\n\njulia> GMtoM = ModuleHomomorphism(G.M, M, [g[1], g[2], g[3]]);\n\njulia> V = vector_bundle(G, M, GMtoM, [g[1] g[4]; g[2] g[4]; g[3] g[4]])\nGKM vector bundle of rank 2 over GKM graph with 3 nodes and valency 2 with weights:\n1: (1, 0, 0, 0), (0, 0, 0, 1)\n2: (0, 1, 0, 0), (0, 0, 0, 1)\n3: (0, 0, 1, 0), (0, 0, 0, 1)\n\njulia> get_connection(V)\nDict{Tuple{Edge, Int64}, Int64} with 12 entries:\n  (Edge(3, 1), 2) => 2\n  (Edge(1, 2), 1) => 1\n  (Edge(3, 1), 1) => 1\n  (Edge(1, 2), 2) => 2\n  (Edge(3, 2), 1) => 1\n  (Edge(2, 3), 1) => 1\n  (Edge(3, 2), 2) => 2\n  (Edge(2, 3), 2) => 2\n  (Edge(1, 3), 1) => 1\n  (Edge(2, 1), 1) => 1\n  (Edge(1, 3), 2) => 2\n  (Edge(2, 1), 2) => 2\n\nIt is visible here that the vector bundle is a direct sum of two line bundles, since we have (e, i) => i for each edge e and index i. The output will be more complicated when the vector bundle does not split into line bundles.\n\n\n\n\n\n","category":"method"},{"location":"GKM/Vectorbundles/#Oscar.projectivization","page":"Vector Bundles","title":"Oscar.projectivization","text":"projectivization(V::GKM_vector_bundle) -> AbstractGKM_graph\n\nReturn the projectivisation of the given equivariant vector bundle.\n\nnote: Note\nIf the given bundle does not admit a unique connection, it must be specified manually by setting the field V.con.\n\nExample\n\njulia> G = projective_space(GKM_graph, 2);\n\njulia> M = free_module(ZZ, 4);\n\njulia> g = gens(M);\n\njulia> GMtoM = ModuleHomomorphism(G.M, M, [g[1], g[2], g[3]]);\n\njulia> V1 = line_bundle(G, M, GMtoM, [gens(M)[4], gens(M)[4], gens(M)[4]]);\n\njulia> V2 = line_bundle(G, M, GMtoM, [gens(M)[1], gens(M)[2], gens(M)[3]]);\n\njulia> V = direct_sum(V1, V2)\nGKM vector bundle of rank 2 over GKM graph with 3 nodes and valency 2 with weights:\n1: (0, 0, 0, 1), (1, 0, 0, 0)\n2: (0, 0, 0, 1), (0, 1, 0, 0)\n3: (0, 0, 0, 1), (0, 0, 1, 0)\n\njulia> P = projectivization(V)\nGKM graph with 6 nodes, valency 3 and axial function:\n[1]_2 -> [1]_1 => (-1, 0, 0, 1)\n[2]_1 -> [1]_1 => (-1, 1, 0, 0)\n[2]_2 -> [1]_2 => (-1, 1, 0, 0)\n[2]_2 -> [2]_1 => (0, -1, 0, 1)\n[3]_1 -> [1]_1 => (-1, 0, 1, 0)\n[3]_1 -> [2]_1 => (0, -1, 1, 0)\n[3]_2 -> [1]_2 => (-1, 0, 1, 0)\n[3]_2 -> [2]_2 => (0, -1, 1, 0)\n[3]_2 -> [3]_1 => (0, 0, -1, 1)\n\nThe naming convention for the vertices of the projectivization's GKM graph is [v]_i where v is a vertex of the original GKM graph and i is the index of the line bundle direct summand to which this vertex of the projectivization corresponds.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Vectorbundles/#GKMtools.tangent_bd-Tuple{GKMtools.AbstractGKM_graph}","page":"Vector Bundles","title":"GKMtools.tangent_bd","text":"tangent_bd(G::AbstractGKM_graph; scaling_weight::Int64 = 1) -> GKM_vector_bundle\n\nReturn the tangent bundle of G. The torus is enlarged by one dimension where the extra factor scales the fibers of the tangent bundle. The default weight is 1, but can be changed using the optional argument scaling_weight if desired.\n\nExample\n\njulia> G = projective_space(GKM_graph, 2)\nGKM graph with 3 nodes, valency 2 and axial function:\n2 -> 1 => (-1, 1, 0)\n3 -> 1 => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\n\njulia> T = tangent_bd(G)\nGKM vector bundle of rank 2 over GKM graph with 3 nodes and valency 2 with weights:\n1: (1, -1, 0, 1), (1, 0, -1, 1)\n2: (-1, 1, 0, 1), (0, 1, -1, 1)\n3: (-1, 0, 1, 1), (0, -1, 1, 1)\n\njulia> P = projectivization(T)\nGKM graph is valid but not 3-independent, so connections may not be unique.\nGKM graph with 6 nodes, valency 3 and axial function:\n[1]_2 -> [1]_1 => (0, -1, 1, 0)\n[2]_1 -> [1]_1 => (-1, 1, 0, 0)\n[2]_2 -> [1]_2 => (-1, 1, 0, 0)\n[2]_2 -> [2]_1 => (-1, 0, 1, 0)\n[3]_1 -> [1]_2 => (-1, 0, 1, 0)\n[3]_1 -> [2]_1 => (0, -1, 1, 0)\n[3]_2 -> [1]_1 => (-1, 0, 1, 0)\n[3]_2 -> [2]_2 => (0, -1, 1, 0)\n[3]_2 -> [3]_1 => (-1, 1, 0, 0)\n\njulia> betti_numbers(P)\n4-element Vector{Int64}:\n 1\n 2\n 2\n 1\n\n\n\n\n\n","category":"method"},{"location":"GKM/Vectorbundles/#GKMtools.cotangent_bd-Tuple{GKMtools.AbstractGKM_graph}","page":"Vector Bundles","title":"GKMtools.cotangent_bd","text":"cotangent_bd(G::AbstractGKM_graph; scaling_weight::Int64 = 1) -> GKM_vector_bundle\n\nReturn the cotangent bundle of G. The torus is enlarged by one dimension where the extra factor scales the fibers of the tangent bundle. The default weight is 1, but can be changed using the optional argument scaling_weight if desired.\n\nExample\n\njulia> G = projective_space(GKM_graph, 3)\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\n\njulia> T = cotangent_bd(G)\nGKM vector bundle of rank 3 over GKM graph with 4 nodes and valency 3 with weights:\n1: (-1, 1, 0, 0, 1), (-1, 0, 1, 0, 1), (-1, 0, 0, 1, 1)\n2: (1, -1, 0, 0, 1), (0, -1, 1, 0, 1), (0, -1, 0, 1, 1)\n3: (1, 0, -1, 0, 1), (0, 1, -1, 0, 1), (0, 0, -1, 1, 1)\n4: (1, 0, 0, -1, 1), (0, 1, 0, -1, 1), (0, 0, 1, -1, 1)\n\n\n\n\n\n","category":"method"},{"location":"GKM/LowdimExamples/#Low-dimensional-examples","page":"Low dimensional examples","title":"Low dimensional examples","text":"","category":"section"},{"location":"GKM/LowdimExamples/","page":"Low dimensional examples","title":"Low dimensional examples","text":"In this section we construct specific relevant GKM graphs.","category":"page"},{"location":"GKM/LowdimExamples/#Low-dimensional-GKM-graphs","page":"Low dimensional examples","title":"Low-dimensional GKM graphs","text":"","category":"section"},{"location":"GKM/LowdimExamples/#GKMtools.gkm_2d","page":"Low dimensional examples","title":"GKMtools.gkm_2d","text":"gkm_2d(w::Matrix{Int64}) -> AbstractGKM_graph\n\nReturn the 2-valent GKM cyclic connected GKM graph whose vertices are 12dotsn and whose edges are (1 2) (2 3)  (n 1). The weights of those edges are given by the rows of the matrix w.\n\nExample\n\nThe following example is the GKM graph from [GKZ24, Example 2.44, left figure], which cannot come from a Hamiltonian action. One way of seeing this is that the combinatorial Betti numbers are not the geometric Betti numbers of any connected space.\n\njulia> G = gkm_2d([1 0; 0 1; -1 0; 0 -1; 1 0; 0 1; -1 0; 0 -1;])\nGKM graph with 8 nodes, valency 2 and axial function:\n2 -> 1 => (-1, 0)\n3 -> 2 => (0, -1)\n4 -> 3 => (1, 0)\n5 -> 4 => (0, 1)\n6 -> 5 => (-1, 0)\n7 -> 6 => (0, -1)\n8 -> 1 => (0, -1)\n8 -> 7 => (1, 0)\n\njulia> betti_numbers(G)\n3-element Vector{Int64}:\n 2\n 4\n 2\n\n\n\n\n\n","category":"function"},{"location":"GKM/LowdimExamples/#GKMtools.gkm_3d_positive_non_toric","page":"Low dimensional examples","title":"GKMtools.gkm_3d_positive_non_toric","text":"gkm_3d_positive_non_toric(i::Int64) -> AbstractGKM_graph\n\nReturn the i-th GKM graph from [CK23, Appendix A]'s classification of 3-valent Hamiltonian positive GKM-graphs with 2-dimensional torus-action that are not projections of GKM graphs coming from smooth projective polytopes.\n\nThe argument i runs from 1 ot 7 and is the index in the list.\n\nExample\n\nWe reproduce here the Betti numbers and the integrals int_M (c_1(M))^3 as listed in [CK23, Appendix A].\n\njulia> for i in 1:7\n           G = gkm_3d_positive_non_toric(i)\n           integral = integrate(first_chern_class(G)^3, G)\n           println(\"Graph $i: Betti numbers = $(betti_numbers(G)), [M] . (c_1(M))^3 = $integral\")\n         end\nGraph 1: Betti numbers = [1, 1, 1, 1], [M] . (c_1(M))^3 = 54\nGraph 2: Betti numbers = [1, 2, 2, 1], [M] . (c_1(M))^3 = 30\nGraph 3: Betti numbers = [1, 2, 2, 1], [M] . (c_1(M))^3 = 40\nGraph 4: Betti numbers = [1, 2, 2, 1], [M] . (c_1(M))^3 = 46\nGraph 5: Betti numbers = [1, 2, 2, 1], [M] . (c_1(M))^3 = 48\nGraph 6: Betti numbers = [1, 3, 3, 1], [M] . (c_1(M))^3 = 26\nGraph 7: Betti numbers = [1, 3, 3, 1], [M] . (c_1(M))^3 = 38\n\n\n\n\n\n","category":"function"},{"location":"GKM/LowdimExamples/#GKMtools.gkm_3d_twisted_flag","page":"Low dimensional examples","title":"GKMtools.gkm_3d_twisted_flag","text":"gkm_3d_twisted_flag() -> AbstractGKM_graph\n\nReturn the 3-valent GKM graph of the twisted flag varieties of Eschenburg, Tolman, and Woodward (see [GKZ23, Example 4.8] and references therein).\n\nExample\n\nNote that the resulting GKM graph does not occur in the output of gkm_3d_positive_non_toric() since one edge has non-positive Chern number.\n\njulia> G = gkm_3d_twisted_flag()\nGKM graph with 6 nodes, valency 3 and axial function:\n2 -> 1 => (0, -1)\n3 -> 2 => (1, 0)\n4 -> 1 => (1, -2)\n4 -> 3 => (-1, 1)\n5 -> 2 => (1, -1)\n5 -> 4 => (0, -1)\n6 -> 1 => (1, -1)\n6 -> 3 => (2, -1)\n6 -> 5 => (1, 0)\n\njulia> print_curve_classes(G)\n2 -> 1: (0, 1), Chern number: 4\n3 -> 2: (-1, 1), Chern number: 2\n4 -> 1: (1, 0), Chern number: 2\n4 -> 3: (-2, 1), Chern number: 0\n5 -> 2: (1, 0), Chern number: 2\n5 -> 4: (-1, 1), Chern number: 2\n6 -> 1: (1, 1), Chern number: 6\n6 -> 3: (1, 0), Chern number: 2\n6 -> 5: (0, 1), Chern number: 4\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#Cohomology","page":"Cohomology","title":"Cohomology","text":"","category":"section"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"Let X be a GKM variety with respect to the complex torus T. By [GKM98], we have the following description of its equivariant cohomology ring H^*_T(XmathbbQ).","category":"page"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"Each fixed point xin X gives a ring homomorphism H^*_T(XmathbbQ)rightarrow H^*_T(xmathbbQ)cong mathbbQmathfrakt. We may combine these maps by taking all fixed points at once. Let V be the set of fixed points of X and E the set of T-invariant rational curves. That is, V are the vertices of the GKM graph and E the edges. Then the map","category":"page"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"    H^*_T(XmathbbQ) longrightarrow bigoplus_xin V mathbbQmathfrakt","category":"page"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"is injective and its image consists of all (f_x)_xin V such that f_textsrc(e)equiv f_textdst(e) mod w(e) for all edges ein E, where w(e) is the weight of e.","category":"page"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"We may further identify mathbbQmathfraktcong mathbbQt_1dotst_r where r=dim_mathbbC(T). Hence, this package represents elements of H^*_T(XmathbbQ) as tuples of polynomials indexed by vertices of the GKM graph.","category":"page"},{"location":"GKM/Cohomology/#GKMtools.is_gkm_class","page":"Cohomology","title":"GKMtools.is_gkm_class","text":"is_gkm_class(c::FreeModElem{QQMPolyRingElem}, G::AbstractGKM_graph) -> Bool\n\nReturn true if the given class represents an actual cohomology class. This holds if and only if the difference between localizations at fixed points connected through an edge e is divisible by the weight of e (see above)\n\nExamples\n\nStandard functions for accessing cohomology classes always yield GKM classes:\n\njulia> G = projective_space(GKM_graph, 1);\n\njulia> is_gkm_class(point_class(G, 1), G)\ntrue\n\nMoreover, equivariant cohomology is a ring and a module over the coefficient ring:\n\njulia> is_gkm_class(point_class(G, 1)^2 * point_class(G, 2), G)\ntrue\n\nHowever, it is possible to cook up non-GKM classes manually. In the example below, this is because w(e)=t_1-t_2, which does not divide t_1^2 - t_2. Here, e is the unique edge of the GKM graph of mathbbP^1.\n\njulia> (t1, t2) = gens(G.equivariantCohomology.coeffRing);\n\njulia> (e0, e1) = gens(G.equivariantCohomology.cohomRing);\n\njulia> c = t1^2 * e0 + t2 * e1\nt1^2*e[1] + t2*e[2]\n\njulia> is_gkm_class(c, G)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#Oscar.IntersectionTheory.point_class","page":"Cohomology","title":"Oscar.IntersectionTheory.point_class","text":"point_class(vertexLabel::String, G::AbstractGKM_graph) -> FreeModElem{QQMPolyRingElem}\n\nReturn the equivariant Poincare dual of the fixed point with given label.\n\n\n\n\n\npoint_class(vertex::Int, G::AbstractGKM_graph) -> FreeModElem{QQMPolyRingElem}\n\nReturn the equivariant Poincare dual of the given fixed point.\n\nExamples\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> point_class(1, P2)\n(t1^2 - t1*t2 - t1*t3 + t2*t3)*e[1]\n\njulia> F3 = flag_variety(GKM_graph, [1, 1, 1]);\n\njulia> point_class(1, F3)\n(t1^2*t2 - t1^2*t3 - t1*t2^2 + t1*t3^2 + t2^2*t3 - t2*t3^2)*e[1]\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.poincare_dual","page":"Cohomology","title":"GKMtools.poincare_dual","text":"poincare_dual(gkmSub::AbstractGKM_subgraph) -> FreeModElem{QQMPolyRingElem}\n\nReturn the equivariant Poincare dual cohomology class of the GKM subgraph.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> P1inP2 = gkm_subgraph_from_vertices(P2, [1, 2])\nGKM subgraph of:\nGKM graph with 3 nodes, valency 2 and axial function:\n2 -> 1 => (-1, 1, 0)\n3 -> 1 => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1, 0)\n\njulia> poincare_dual(P1inP2)\n(t1 - t3)*e[1] + (t2 - t3)*e[2]\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.weight_class","page":"Cohomology","title":"GKMtools.weight_class","text":"weight_class(e::Edge, G::AbstractGKM_graph) -> QQMPolyRingElem\n\nReturn the weight of the edge e as an element of the coefficient ring of the equivariant cohomology theory.\n\nExample\n\njulia> H7 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 7))\nGKM graph with 4 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1, 0)\n3 -> 2 => (7, 1, 0, -1)\n4 -> 1 => (0, 1, 7, -1)\n4 -> 3 => (-1, 0, 1, 0)\n\njulia> weight_class(Edge(3, 2), H7)\n7*t1 + t2 - t4\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.euler_class","page":"Cohomology","title":"GKMtools.euler_class","text":"euler_class(vertex::Int, G::AbstractGKM_graph) -> QQMPolyRingElem\n\nReturn the Euler class of the normal bundle of the fixed point v. This is the localization of point_class(vertex, G) to the given vertex.\n\nExample\n\njulia> F3 = flag_variety(GKM_graph, [1, 1, 1]);\n\njulia> euler_class(1, F3)\nt1^2*t2 - t1^2*t3 - t1*t2^2 + t1*t3^2 + t2^2*t3 - t2*t3^2\n\njulia> point_class(1, F3)\n(t1^2*t2 - t1^2*t3 - t1*t2^2 + t1*t3^2 + t2^2*t3 - t2*t3^2)*e[1]\n\n\n\n\n\neuler_class(vertexLabel::String, G::AbstractGKM_graph) -> QQMPolyRingElem\n\nReturn the euler class of the normal bundle of the fixed point with the given label.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.integrate_gkm_class","page":"Cohomology","title":"GKMtools.integrate_gkm_class","text":"integrate_gkm_class(class::FreeModElem{QQMPolyRingElem}, G::AbstractGKM_graph; check::Bool=true) -> QQMPolyRingElem\n\nIntegrate the GKM class, yielding an element of the coefficient ring. This checks if is_gkm_class(class,R) == true and throws an error otherwise.\n\nExamples\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> integrate_gkm_class(point_class(1, P2), P2)\n1\n\njulia> P2inP1 = gkm_subgraph_from_vertices(P2, [1, 2]);\n\njulia> pd = poincare_dual(P2inP1);\n\njulia> integrate_gkm_class(pd, P2)\n0\n\njulia> integrate_gkm_class(pd^2, P2)\n1\n\njulia> (t1, t2, t3) = gens(P2.equivariantCohomology.coeffRing);\n\njulia> integrate_gkm_class(t3 * pd^2 + (t2^2 - t1)*point_class(3, P2), P2)\n-t1 + t2^2 + t3\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#Nemo.integrate","page":"Cohomology","title":"Nemo.integrate","text":"integrate(class::FreeModElem{QQMPolyRingElem}, G::AbstractGKM_graph, e::Edge) -> AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}\n\nIntegrate the cohomology class over the curve represented by the GKM graph edge. In mathematical notation, if the edge is e = (prightarrow q) and the class is c=(f_v)_vin X^T then int_e c = fracf_p - f_qw(e) where w(e) is the weight of e. If is_gkm_class(class, G) == true then the result is a polynomial in the variables gens(G.equivariantCohomology.coeffRing).\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> integrate(first_chern_class(P2), P2, Edge(1, 2))\n3\n\n\n\n\n\nintegrate(class::FreeModElem{QQMPolyRingElem}, G::AbstractGKM_graph) -> AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}\n\nIntegrate the cohomology class, yielding an element of the fraction field of the equivariant coefficient ring.\n\nThis uses the Atiyah–Bott localization formula:  If c = (f_v)_vin X^T then int_X c = sum_vin X^Tfracf_ve_T(T_vX) where e_T(T_vX) is the equivariant Euler class of the tangent bundle of X at the fixed point v.\n\nIf is_gkm_class(class, G) == true, this fraction will be a polynomial.\n\nnote: Note\nUse integrate_gkm_class() instead if you know that the class is a GKM class.\n\nExamples\n\njulia> G24 = flag_variety(GKM_graph, [2, 4]); # Grassmannian of 2-planes in C^4\n\njulia> integrate(point_class(G24, 1), G24)\n1\n\nIn contrast to integrate_gkm_class, we can also integrate tuples (f_v)_vin X^T that do not satisfy is_gkm_class(class) == true:\n\njulia> P1 = projective_space(GKM_graph, 1);\n\njulia> (t1, t2) = gens(P1.equivariantCohomology.coeffRing);\n\njulia> (e0, e1) = gens(P1.equivariantCohomology.cohomRing);\n\njulia> c = t1^2 * e0 + t2 * e1\nt1^2*e[1] + t2*e[2]\n\njulia> is_gkm_class(c, P1)\nfalse\n\njulia> integrate(c, P1)\n(t1^2 - t2)//(t1 - t2)\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.first_chern_class","page":"Cohomology","title":"GKMtools.first_chern_class","text":"first_chern_class(G::AbstractGKM_graph) -> FreeModElem{QQMPolyRingElem}\n\nReturn the equivariant first Chern class of the GKM space, i.e., c_1^T(TX) where TX is the (T-equivariant) tangent bundle of X.\n\nExamples\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> first_chern_class(P2)\n(2*t1 - t2 - t3)*e[1] + (-t1 + 2*t2 - t3)*e[2] + (-t1 - t2 + 2*t3)*e[3]\n\njulia> H3 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 3))\nGKM graph with 4 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1, 0)\n3 -> 2 => (3, 1, 0, -1)\n4 -> 1 => (0, 1, 3, -1)\n4 -> 3 => (-1, 0, 1, 0)\n\njulia> first_chern_class(H3)\n(-t1 - t2 - 2*t3 + t4)*e[1] + (-2*t1 - t2 - t3 + t4)*e[2] + (4*t1 + t2 - t3 - t4)*e[3] + (-t1 + t2 + 4*t3 - t4)*e[4]\n\n\n\n\n\nfirst_chern_class(R::GKM_cohomology_ring) -> FreeModElem{QQMPolyRingElem}\n\nReturn the equivariant first Chern class of the GKM space of which R is the cohomology ring.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#Constructors","page":"Constructors","title":"Constructors","text":"","category":"section"},{"location":"GKM/Constructors/","page":"Constructors","title":"Constructors","text":"These functions allow the construction of GKM varieties.","category":"page"},{"location":"GKM/Constructors/#GKMtools.gkm_graph","page":"Constructors","title":"GKMtools.gkm_graph","text":"gkm_graph(g, labels, M, w; check=true, checkLabels=true) -> AbstractGKM_graph\n\nCreate a GKM graph from the given data.\n\nArguments\n\ng::Graph: An unoriented OSCAR graph.\nlabels::Vector{String}: A vector of strings, used to denote the vertices.\nM::AbstractAlgebra.Generic.FreeModule{R}: A OSCAR free module over mathbbZ or mathbbQ, it denotes the character group. R is either ZZRingElem or QQFieldElem.\nw::Dict{Edge, AbstractAlgebra.Generic.FreeModuleElem{R}}: The axial function. Note that it is enough to specify the weight of each edge in one orientation here. The opposite oriented edge will automatically be given minus that weight.\ncheck::Bool=true: Check if the data inserted are consistent.\ncheckLabels::Bool=true: Check that the labels don't contain the characters <, [, ], which are reserved for the output of special constructions like blowups and projective bundles.\n\nExample\n\nLet us construct the GKM graph of the projective line. First of all, we create a graph with two vertices, and one edge.\n\njulia> g = Graph{Undirected}(2)\nUndirected graph with 2 nodes and no edges\n\njulia> add_edge!(g, 1, 2);\n\nLet us define our array of labels.\n\njulia> labels = [\"a\", \"b\"];\n\nNow, we create the character group. We take a free module of rank 2 over the integers.\n\njulia> M = free_module(ZZ, 2)\nFree module of rank 2 over ZZ\n\nWe create the axial function. It is a dictionary from the set of edges to the character group. This time we have only one edge.\n\njulia> e = first(edges(g));\n\njulia> w = Dict(e => gens(M)[1] - gens(M)[2])\nDict{Edge, AbstractAlgebra.Generic.FreeModuleElem{ZZRingElem}} with 1 entry:\n  Edge(2, 1) => (1, -1)\n\nFinally, we create the GKM graph.\n\njulia> gkm_graph(g, labels, M, w)\nGKM graph with 2 nodes, valency 1 and axial function:\nb -> a => (1, -1)\n\nwarning: Warning\nDo not change the number of verices after this.\nDon't modify the underlying OSCAR graph directly after this. Use the functions of this package instead.\nAll edges should be added immediately after calling this function and not changed afterwards.\n\nnote: Note\nAfter you have added all edges using add_edge!, you may use initialize! to calculate the GKM connection (if it is unique) and the curve classes. If you don't do this, those data will be calculated whenever required for the first time.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#GKMtools.empty_gkm_graph","page":"Constructors","title":"GKMtools.empty_gkm_graph","text":"empty_gkm_graph(n::Int64, r::Int64, labels::Vector{String}) -> AbstractGKM_graph\nempty_gkm_graph(n::Int64, r::Int64, labels::Vector{String}) -> AbstractGKM_graph\n\nReturn the GKM graph with n fixed points, no edges, torus rank r and vertices labelled by labels. Return the GKM graph with n fixed points, no edges, torus rank r and vertices labelled by labels.\n\njulia> G = empty_gkm_graph(2, 2, [\"a\", \"b\"])\nGKM graph with 2 nodes, valency 0 and axial function:\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#Oscar.add_edge!","page":"Constructors","title":"Oscar.add_edge!","text":"add_edge!(G::AbstractGKM_graph, s::String, d::String, weight::AbstractAlgebra.Generic.FreeModuleElem{R}) where R<:GKM_weight_type\n\nAdd an edge to G from the vertex labelled s to the vertex labelled d, the axial function takes value weight in that edge.\n\nLet us construct the same example of gkm_graph, that is the GKM graph of the projective space. \n\njulia> G = empty_gkm_graph(2, 2, [\"a\", \"b\"])\nGKM graph with 2 nodes, valency 0 and axial function:\n\njulia> wei = gens(G.M)[1] - gens(G.M)[2]\n(1, -1)\n\njulia> add_edge!(G, \"b\", \"a\", wei);\n\njulia> G\nGKM graph with 2 nodes, valency 1 and axial function:\nb -> a => (1, -1)\n\n\nwarning: Warning\nAdd all edges immediately after creation. Any curve class or cohomology functionality should only be used after all edges have been added. The same holds for initialize!.\n\n\n\n\n\nadd_edge!(G::AbstractGKM_graph, s::String, d::String, weight::AbstractAlgebra.Generic.FreeModuleElem{R}) where R<:GKM_weight_type\n\nSame as before, but using the number of the vertex instead of the label.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#GKMtools.initialize!","page":"Constructors","title":"GKMtools.initialize!","text":"initialize!(gkm::AbstractGKM_graph; connection::Bool=true, curveClasses::Bool=true)\n\nYou may optionally call this function as soon as all edges have been added to the GKM graph to calculate the GKM connection (if unique) and the curve classes of the gkm graph. This will set the fields gkm.connection and gkm.curveClasses that are initially nothing. If you don't call this, these fields will be initialized later if possible, which might take some time at unexpected moments (especially for curveClasses). If any of those fields are already set, this will not overwrite them.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#GKMtools.convert_weights","page":"Constructors","title":"GKMtools.convert_weights","text":"convert_weights(G::AbstractGKM_graph) -> AbstractGKM_graph{QQFieldElem}\n\nIt returns G, but the character group will be embedded into a free mathbbQ-module.\n\nExamples\n\njulia> G_over_Z = generalized_gkm_flag(root_system(:A, 1))\nGKM graph with 2 nodes, valency 1 and axial function:\ns1 -> id => (-1, 1)\n\njulia> typeof(G_over_Z)\nGKMtools.AbstractGKM_graph{ZZRingElem}\n\njulia> G_over_Q = convert_weights(G_over_Z)\nGKM graph with 2 nodes, valency 1 and axial function:\ns1 -> id => (-1, 1)\n\njulia> typeof(G_over_Q)\nGKMtools.AbstractGKM_graph{QQFieldElem}\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#Base.isvalid-Tuple{GKMtools.AbstractGKM_graph}","page":"Constructors","title":"Base.isvalid","text":"isvalid(gkm::AbstractGKM_graph; printDiagnostics::Bool=true) -> Bool\n\nReturn true if the GKM graph is valid. This means:\n\nEvery vertex has the same degree\nThe weights are defined for every edge and every reverse of every edge\nThe weights belong to the weight lattice\nThe weights of an edge and its reverse sum to zero\nThere are the right number of vertex labels\nIf the valency is at least two, the weights of the graph are 2-independent.\nVertex labels must be unique\nThe equivariant cohomology ring has rank = number of vertices of graph\nThe coefficient ring of the equivariant cohomology ring has number of generators = torus rank.\n\nExamples\n\nThe standard constructions always produce valid GKM graphs, e.g. the complex projective space mathbbP^3:\n\njulia> isvalid(projective_space(GKM_graph, 3))\ntrue\n\nOn the other hand, here is an example showing why one should never modify the underlying OSCAR graph of a GKM graph directly:\n\njulia> G = empty_gkm_graph(3, 1, [\"v1\", \"v2\", \"v3\"])\nGKM graph with 3 nodes, valency 0 and axial function:\n\njulia> add_edge!(G.g, 1, 2)\ntrue\n\njulia> isvalid(G)\nThe valency is not the same for all vertices\nfalse\n\njulia> add_edge!(G.g, 1, 3)\ntrue\n\njulia> add_edge!(G.g, 2, 3)\ntrue\n\njulia> isvalid(G)\nWeight of Edge(2, 1) is missing.\nfalse\n\nInstead, one should add all edges with add_edge!(G, \"v1\", \"v2\", weight) (see above).\n\n\n\n\n\n","category":"method"},{"location":"GKM/CurveClasses/#Curve-Classes","page":"Curve Classes","title":"Curve Classes","text":"","category":"section"},{"location":"GKM/CurveClasses/","page":"Curve Classes","title":"Curve Classes","text":"Given a GKM variety X, every edge e of its GKM graph corresponds to a T-invariant rational curve C_e in X, and hence to a second homology class C_ein H_2(XmathbbZ). As we discuss in the supporting paper, it turns out that:","category":"page"},{"location":"GKM/CurveClasses/","page":"Curve Classes","title":"Curve Classes","text":"The subgroup of H_2(XmathbbZ) generated by C_e  e text an edge of the GKM graph coincides with the subgroup generated  by algebraic cycles.\nThe weights of the GKM graph give rise to an explicit presentation of this subgroup in terms of a complete set of relations between the C_e classes.","category":"page"},{"location":"GKM/CurveClasses/","page":"Curve Classes","title":"Curve Classes","text":"This is the basis on which this package handles curve classes of GKM spaces.","category":"page"},{"location":"GKM/CurveClasses/#GKMtools.print_curve_classes","page":"Curve Classes","title":"GKMtools.print_curve_classes","text":"print_curve_classes(G::AbstractGKM_graph)\n\nFor each edge, print the representative of its curve class and its Chern numner.\n\nExamples\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> print_curve_classes(P2)\n2 -> 1: (1), Chern number: 3\n3 -> 1: (1), Chern number: 3\n3 -> 2: (1), Chern number: 3\n\njulia> H5 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 5));\n\njulia> print_curve_classes(H5)\n2 -> 1: (-5, 1), Chern number: -3\n3 -> 2: (1, 0), Chern number: 2\n4 -> 1: (1, 0), Chern number: 2\n4 -> 3: (0, 1), Chern number: 7\n\njulia> P2_blown_up = blow_up(gkm_subgraph_from_vertices(P2, [1]))\nGKM subgraph of:\nGKM graph with 4 nodes, valency 2 and axial function:\n[1>3] -> [1>2] => (0, -1, 1)\n2 -> [1>2] => (-1, 1, 0)\n3 -> [1>3] => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n[1>3] -> [1>2] => (0, -1, 1)\n\njulia> print_curve_classes(P2_blown_up.super)\n[1>3] -> [1>2]: (-1, 1), Chern number: 1\n2 -> [1>2]: (1, 0), Chern number: 2\n3 -> [1>3]: (1, 0), Chern number: 2\n3 -> 2: (0, 1), Chern number: 3\n\n\n\n\n\n","category":"function"},{"location":"GKM/CurveClasses/#GKMtools.curve_class","page":"Curve Classes","title":"GKMtools.curve_class","text":"curve_class(G::AbstractGKM_graph, src::String, dst::String)\n\nReturn the second homology class represented by the given edge whose source and destination have the given labels.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> P2_blown_up = blow_up(gkm_subgraph_from_vertices(P2, [1]))\nGKM subgraph of:\nGKM graph with 4 nodes, valency 2 and axial function:\n[1>3] -> [1>2] => (0, -1, 1)\n2 -> [1>2] => (-1, 1, 0)\n3 -> [1>3] => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n[1>3] -> [1>2] => (0, -1, 1)\n\njulia> curve_class(P2_blown_up.super, \"[1>3]\", \"[1>2]\")\n(-1, 1)\n\n\n\n\n\ncurve_class(G::AbstractGKM_graph, e::Edge)\n\nReturn the second homology class represented by the given edge.\n\n\n\n\n\n","category":"function"},{"location":"GKM/CurveClasses/#Oscar.IntersectionTheory.chern_number","page":"Curve Classes","title":"Oscar.IntersectionTheory.chern_number","text":"chern_number(e::Edge, G::AbstractGKM_graph) -> ZZRingElem\n\nReturn the Chern number of the curve class represented by the given edge. This is the pairing of the curve class with the first Chern class of the tangent bundle.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> chern_number(Edge(1, 2), P2)\n3\n\njulia> partialFlagVariety = flag_variety(GKM_graph, [1, 2, 3, 1]);\n\njulia> chern_number(Edge(1, 2), partialFlagVariety)\n4\n\n\n\n\n\nchern_number(G::AbstractGKM_graph, beta::CurveClass_type; check::Bool=true)::ZZRingElem\n\nReturn the Chern number of the curve class beta. This is the pairing of the second homology class with the first Chern class of the tangent bundle.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> chern_number(P2, 2 * curve_class(P2, Edge(1, 2)))\n6\njulia> chern_number(P2, -2 * curve_class(P2, Edge(1, 2)) + curve_class(P2, Edge(2, 3)))\n-3\n\n\n\n\n\n","category":"function"},{"location":"GKM/CurveClasses/#Hecke.is_effective","page":"Curve Classes","title":"Hecke.is_effective","text":"is_effective(G::AbstractGKM_graph, beta::CurveClass_type) -> Bool\n\nReturn whether beta is in the effective cone, i.e. whether it is a non-negative linear combination of edge curve classes.\n\nnote: Note\nWe consider the effective cone to be closed and hence zero is also considered effective.\n\nExamples\n\njulia> F3 = flag_variety(GKM_graph, [1, 1, 1]);\n\njulia> beta = curve_class(F3, Edge(1, 2));\n\njulia> is_effective(F3, beta)\ntrue\n\njulia> is_effective(F3, 0*beta)\ntrue\n\njulia> is_effective(F3, -1*beta)\nfalse\n\njulia> is_effective(F3, 2*beta)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"GKM/CurveClasses/#GKMtools.GKM_second_homology","page":"Curve Classes","title":"GKMtools.GKM_second_homology","text":"GKM_second_homology(G::AbstractGKM_graph) - GKM_H2\n\nBuild (if necessary) and return the GKM_H2 object of this GKM graph. Assume that G represents a GKM variety X. Then the returned ans.H2 is by definition the quotient of the mathbbZ-module generated by the GKM graph's edges modulo the relations in H_2(XmathbbZ). Thus, ans.H2 is the submodule of H_2(XmathbbZ) generated by classes of T-invariant curves.\n\nnote: Note\nIf G.curveClasses is already set, it just returns that. Otherwise it calculates it afresh and stores it there.\nFor most applications, it is not necessary to work with this object directly. Use functions like curve_class and chern_number instead.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Seidelspace/#Seidel-Space","page":"Seidel Space","title":"Seidel Space","text":"","category":"section"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"We follow [Iri17, Definition 3.2] in our description of the Seidel space. Let X be a (smooth) GKM variety with torus action by T. Let iotacolonmathbbC^timesrightarrow T be a group homomorphism.","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"The Seidel space S_X associated to this datum is a X-bundle over mathbbP^1 which is trivialized over","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"  beginalign*\n    U_0 = 1u  uinmathbbCsubsetmathbbP^1\n    U_infty = v1  vinmathbbCsubsetmathbbP^1\n  endalign*","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"The transition function on U_0cap U_infty is given by","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"  U_0times X ni (1u x) longmapsto (u^-11 iota(u)cdot x) in U_inftytimes X","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"Globally, it can be described as","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"  S_X = left( mathbbC^2setminus0times X right)  mathbbC^times","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"where lambdainmathbbC^times acts by lambdacdot ((v u) x) = ((lambda v lambda u) iota(lambda)cdot x).","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"Let widehatT= TtimesmathbbC^times. Then widehatT acts on S_X by (t s)cdot ((v su) tcdot x).","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"That is, widehatT acts on S_XrightarrowmathbbP^1 via the T-action on the fibres X and via the standard mathbbC^times-action on the base mathbbP^1.","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"note: Note\nIf X is a GKM space with respect to T, then S_X is a GKM space with respect to widehatT, which is implemented in this package.\nThe GKM graph and connection of S_X is described in the supporting paper.","category":"page"},{"location":"GKM/Seidelspace/#GKMtools.Seidel_space","page":"Seidel Space","title":"GKMtools.Seidel_space","text":"Seidel_space(G::AbstractGKM_graph, w::AbstractAlgebra.Generic.FreeModuleElem{R}; basePoint::Int64 = 1) -> AbstractGKM_graph\n\nConstruct the Seidel space associated to the GKM graph G (representing the GKM variety X) and the map iotamathbbC^timesrightarrow T given by the element winmathfrakt.\n\nOptional arguments:\n\nbasePoint::Int64: This is the vertex of G so that in the internal presentation of the curve classes of S_X, the curve class of the section of S_Xrightarrow mathbbP^1  associated to the vertex basePoint is represented by (0,...,0,1).  The first entries correspond to curve classes of X. The last is the degree of the curve class projected to mathbbP^1.\n\nExamples\n\njulia> G = projective_space(GKM_graph, 2);\n\njulia> S = Seidel_space(G, gens(G.M)[1])\nGKM graph with 6 nodes, valency 3 and axial function:\n[2]_0 -> [1]_0 => (-1, 1, 0, 0)\n[3]_0 -> [1]_0 => (-1, 0, 1, 0)\n[3]_0 -> [2]_0 => (0, -1, 1, 0)\n[1]_inf -> [1]_0 => (0, 0, 0, -1)\n[2]_inf -> [2]_0 => (0, 0, 0, -1)\n[2]_inf -> [1]_inf => (-1, 1, 0, 1)\n[3]_inf -> [3]_0 => (0, 0, 0, -1)\n[3]_inf -> [1]_inf => (-1, 0, 1, 1)\n[3]_inf -> [2]_inf => (0, -1, 1, 0)\n\njulia> S = Seidel_space(G, gens(G.M)[1] + 7*gens(G.M)[2])\nGKM graph with 6 nodes, valency 3 and axial function:\n[2]_0 -> [1]_0 => (-1, 1, 0, 0)\n[3]_0 -> [1]_0 => (-1, 0, 1, 0)\n[3]_0 -> [2]_0 => (0, -1, 1, 0)\n[1]_inf -> [1]_0 => (0, 0, 0, -1)\n[2]_inf -> [2]_0 => (0, 0, 0, -1)\n[2]_inf -> [1]_inf => (-1, 1, 0, -6)\n[3]_inf -> [3]_0 => (0, 0, 0, -1)\n[3]_inf -> [1]_inf => (-1, 0, 1, 1)\n[3]_inf -> [2]_inf => (0, -1, 1, 7)\n\njulia> print_curve_classes(S)\n[2]_0 -> [1]_0: (1, 0), Chern number: 3\n[3]_0 -> [1]_0: (1, 0), Chern number: 3\n[3]_0 -> [2]_0: (1, 0), Chern number: 3\n[1]_inf -> [1]_0: (0, 1), Chern number: -3\n[2]_inf -> [2]_0: (6, 1), Chern number: 15\n[2]_inf -> [1]_inf: (1, 0), Chern number: 3\n[3]_inf -> [3]_0: (-1, 1), Chern number: -6\n[3]_inf -> [1]_inf: (1, 0), Chern number: 3\n[3]_inf -> [2]_inf: (1, 0), Chern number: 3\n\n\nUsing a different base point does not change the resulting GKM graph but gives a different internal presentation of the curve classes.\n\njulia> S = Seidel_space(G, gens(G.M)[1] + 7*gens(G.M)[2]; basePoint=2)\nGKM graph with 6 nodes, valency 3 and axial function:\n[2]_0 -> [1]_0 => (-1, 1, 0, 0)\n[3]_0 -> [1]_0 => (-1, 0, 1, 0)\n[3]_0 -> [2]_0 => (0, -1, 1, 0)\n[1]_inf -> [1]_0 => (0, 0, 0, -1)\n[2]_inf -> [2]_0 => (0, 0, 0, -1)\n[2]_inf -> [1]_inf => (-1, 1, 0, -6)\n[3]_inf -> [3]_0 => (0, 0, 0, -1)\n[3]_inf -> [1]_inf => (-1, 0, 1, 1)\n[3]_inf -> [2]_inf => (0, -1, 1, 7)\n\njulia> print_curve_classes(S)\n[2]_0 -> [1]_0: (1, 0), Chern number: 3\n[3]_0 -> [1]_0: (1, 0), Chern number: 3\n[3]_0 -> [2]_0: (1, 0), Chern number: 3\n[1]_inf -> [1]_0: (-6, 1), Chern number: -3\n[2]_inf -> [2]_0: (0, 1), Chern number: 15\n[2]_inf -> [1]_inf: (1, 0), Chern number: 3\n[3]_inf -> [3]_0: (-7, 1), Chern number: -6\n[3]_inf -> [1]_inf: (1, 0), Chern number: 3\n[3]_inf -> [2]_inf: (1, 0), Chern number: 3\n\n\n\n\n\n","category":"function"},{"location":"GKM/GKM/#Generalities-on-GKM-graphs","page":"GKM Graphs","title":"Generalities on GKM graphs","text":"","category":"section"},{"location":"GKM/GKM/#Definition","page":"GKM Graphs","title":"Definition","text":"","category":"section"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"GKM spaces have been introduced in [GKM98]. Many of the combinatorial definitions in this package follow [GZ00]. For the purpose of this package, by GKM variety we mean a smooth projective varieties over mathbbC with an algebraic torus action such that the action has a finite number of fixed points and a finite number of 1-dimensional orbits.","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"The GKM graph associated to a torus T acting on a GKM variety X is the following datum:","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"A graph having the fixed points as vertices, such that two vertices are connected by an unoriented) edge if there is a 1-dimensional orbit passing through the two fixed points.\nAn axial function mathrmwcolon E rightarrow M from the set of oriented edges of the graph to the weight lattice M of T. (By oriented edge we mean an unoriented edge of the graph plus a choice of orientation.)","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"In this package, the codomain M of the axial function can be a free mathbbZ-module or a free mathbbQ-module. Since the GKM graph of a GKM variety is always regular (with the valency of every vertex being the complex dimension of the space), this package assumes that GKM graphs are regular.","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"Famous examples of GKM varities include projective space, (generalised/partial) flag varieties, smooth Schubert varieties, and smooth toric varieties, see Standard Constructions.","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"This package represents GKM varieties purely by their GKM graphs. For some applications, the additional datum of a GKM connection is necessary, see Connections.","category":"page"},{"location":"GKM/GKM/#Index","page":"GKM Graphs","title":"Index","text":"","category":"section"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"","category":"page"},{"location":"GKM/Properties/#Properties-of-GKM-graphs","page":"Properties","title":"Properties of GKM graphs","text":"","category":"section"},{"location":"GKM/Properties/","page":"Properties","title":"Properties","text":"These are the main properties of GKM graphs.","category":"page"},{"location":"GKM/Properties/#Oscar.betti_numbers","page":"Properties","title":"Oscar.betti_numbers","text":"betti_numbers(G::AbstractGKM_graph) -> Vector{Int64}\n\nReturn the array betti_numbers such that betti_numbers[i+1] is the 2i-th combinatorial Betti number for i from 0 to the valency of G, as defined in [GZ01, section 1.3].\n\nnote: Note\ni ranges from 0 to the valency of G, that can be obtained by valency(G).\nFrom [GZ01, Theorem 1.3.2], the combinatorial Betti numbers equal the Betti numbers of the underlying GKM space if the torus action is Hamiltonian. This holds automatically for smooth projective varieties with algebraic torus action (cf. [MFK94, Example 8.1 (ii)]).\n\nwarning: Warning\nbetti_numbers[1] is the 0-th Betti number, since Julia arrays are 1-based and not 0-based.\n\nExamples\n\njulia> H6 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 6));\n\njulia> betti_numbers(H6)\n3-element Vector{Int64}:\n 1\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.valency","page":"Properties","title":"GKMtools.valency","text":"valency(G::AbstractGKM_graph) -> Int64\n\nReturn the valency of G, i.e. the degree of each vertex.\n\nExample:\n\nThe valency of the GKM graph of mathbbP^3 is 3, since all of the fixed points 1000 dots 0001 are connected to each other via some T-invariant mathbbP^1's. For example, 1000 and 0100 are connected by xy00  xyinmathbbC.\n\njulia> valency(projective_space(GKM_graph, 3))\n3\njulia> valency(grassmannian(GKM_graph, 2, 4)) # The Grassmannian of 2-planes in C^4\n4\njulia> valency(flag_variety(GKM_graph, [1, 1, 1, 1])) # The variety of full flags in C^4\n6\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.rank_torus","page":"Properties","title":"GKMtools.rank_torus","text":"rank_torus(G::AbstractGKM_graph) -> Int64\n\nReturn the rank of the torus acting on G. That is, the rank of the character group.\n\nExamples\n\nBy default, the torus acting on mathbbP^n is (mathbbC^times)^n+1, acting by rescaling the homogeneous coordinates.\n\njulia> P3 = projective_space(GKM_graph, 3);\n\njulia> rank_torus(P3)\n4\n\nTaking products adds the rank:\n\njulia> H6 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 6));\n\njulia> rank_torus(H6)\n4\njulia> rank_torus(H6 * P3)\n8\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.is2_indep","page":"Properties","title":"GKMtools.is2_indep","text":"is2_indep(G::AbstractGKM_graph) -> Bool\n\nReturn true if G is 2-independent, i.e. the weights of every two edges at a vertex are linearly independent.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.is3_indep","page":"Properties","title":"GKMtools.is3_indep","text":"is3_indep(G::AbstractGKM_graph) -> Bool\n\nReturn true if G is 3-independent, i.e. the weights of every three edges at a vertex are linearly independent.\n\nExample\n\nThe weights of mathbbP^3 at the fixed point 1000 are t_i-t_0iin1 2 3, which are linearly independent over mathbbC.\n\njulia> is3_indep(projective_space(GKM_graph, 3))\ntrue\n\nThe variety of complete flags in mathbbC^3 is an example of a GKM graph that is not 3-independent:\n\njulia> G = flag_variety(GKM_graph, [1, 1, 1])\nGKM graph with 6 nodes, valency 3 and axial function:\n13 -> 12 => (0, -1, 1)\n21 -> 12 => (-1, 1, 0)\n23 -> 13 => (-1, 1, 0)\n23 -> 21 => (-1, 0, 1)\n31 -> 13 => (-1, 0, 1)\n31 -> 21 => (0, -1, 1)\n32 -> 12 => (-1, 0, 1)\n32 -> 23 => (0, -1, 1)\n32 -> 31 => (-1, 1, 0)\n\njulia> is3_indep(G)\nfalse\n\nwarning: Warning\nThis function throws an error if the valency of G is less than 3, since in this case it is not possible to pick three different edges ta a vertex.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.is_strictly_nef","page":"Properties","title":"GKMtools.is_strictly_nef","text":"is_strictly_nef(G::AbstractGKM_graph) -> Bool\n\nReturn true if and only if the Chern numbers of all curve classes corresponding to edges of the GKM graph are strictly positive.\n\nExamples\n\njulia> F3 = flag_variety(GKM_graph, [1,1,1]);\n\njulia> print_curve_classes(F3)\n13 -> 12: (0, 1), Chern number: 2\n21 -> 12: (1, 0), Chern number: 2\n23 -> 13: (1, 1), Chern number: 4\n23 -> 21: (0, 1), Chern number: 2\n31 -> 13: (1, 0), Chern number: 2\n31 -> 21: (1, 1), Chern number: 4\n32 -> 12: (1, 1), Chern number: 4\n32 -> 23: (1, 0), Chern number: 2\n32 -> 31: (0, 1), Chern number: 2\n\njulia> is_strictly_nef(F3)\ntrue\n\njulia> H5 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 5))\nGKM graph with 4 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1, 0)\n3 -> 2 => (5, 1, 0, -1)\n4 -> 1 => (0, 1, 5, -1)\n4 -> 3 => (-1, 0, 1, 0)\n\njulia> print_curve_classes(H5)\n2 -> 1: (-5, 1), Chern number: -3\n3 -> 2: (1, 0), Chern number: 2\n4 -> 1: (1, 0), Chern number: 2\n4 -> 3: (0, 1), Chern number: 7\n\njulia> is_strictly_nef(H5)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"GKM/Operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"GKM/Operators/#GKM-Subgraphs","page":"Operators","title":"GKM Subgraphs","text":"","category":"section"},{"location":"GKM/Operators/#GKMtools.gkm_subgraph_from_vertices","page":"Operators","title":"GKMtools.gkm_subgraph_from_vertices","text":"gkm_subgraph_from_vertices(gkm::AbstractGKM_graph, vertices::Vector{Int64}) -> AbstractGKM_subgraph\n\nReturn the GKM subgraph induced by the given vertices.\n\nnote: Note\nThis does not check if the result is a valid GKM graph (use may use isvalid for that).\nIf possible, the subgraph will be endowed with the connection induced from the supergraph.\n\nExample\n\njulia> G = projective_space(GKM_graph, 3)\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\n\njulia> S = gkm_subgraph_from_vertices(G, [2, 3])\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n3 -> 2 => (0, -1, 1, 0)\n\njulia> S.self\nGKM graph with 2 nodes, valency 1 and axial function:\n3 -> 2 => (0, -1, 1, 0)\n\njulia> S.super\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\n\n\n\n\n\n\ngkm_subgraph_from_vertices(gkm::AbstractGKM_graph, vertexLabels::Vector{String}) -> AbstractGKM_subgraph\n\nAs before, but the vertices are given by their labels.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Operators/#GKMtools.gkm_subgraph_from_edges","page":"Operators","title":"GKMtools.gkm_subgraph_from_edges","text":"gkm_subgraph_from_edges(gkm::AbstractGKM_graph, edges::Vector{Edge}) -> AbstractGKM_subgraph\n\nReturn the GKM subgraph induced by the given edges.\n\nnote: Note\nThis does not check if the result is a valid GKM graph (use isvalid for that).\nIf possible, the subgraph will be endowed with the connection induced from the supergraph.\n\nExample\n\njulia> G = projective_space(GKM_graph, 3);\n\njulia> S = gkm_subgraph_from_edges(G, [Edge(1, 2), Edge(2, 3)])\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 3 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 2 => (0, -1, 1, 0)\n\n\n\n\n\n","category":"function"},{"location":"GKM/Operators/#Base.isvalid-Tuple{GKMtools.AbstractGKM_subgraph}","page":"Operators","title":"Base.isvalid","text":"isvalid(gkmsub::AbstractGKM_subgraph; printDiagnostics::Bool = true) -> Bool\n\nReturn true if the given GKM subgraph is valid. This holds if and only if all of the following hold:\n\nThe supergraph and subgraph are both valid GKM GKMsubgraphs of the same character group\nThe subgraph is mathematically a subgraph of the supergraph\nThe edge weights of the subgraph match that of the supergraph\nThe vertex labels of the subgraph and the supergraph match.\n\nwarning: Warning\nIf a connection for the supergraph is set, this does not check if it is compatible with the subgraph. Use is_compatible_with_connection() for this.\n\n\n\n\n\n","category":"method"},{"location":"GKM/Operators/#Blowups","page":"Operators","title":"Blowups","text":"","category":"section"},{"location":"GKM/Operators/#Oscar.blow_up","page":"Operators","title":"Oscar.blow_up","text":"blow_up(gkmSub::AbstractGKM_subgraph) -> AbstractGKM_subgraph\n\nReturn the tuple (GKM graph of blowup, GKM graph of exceptional divisor) from (GKM graph, GKM subgraph, connection on supergraph), where both are encoded as AbstractGKM_subgraph.\n\nnote: Note\nThe GKM graph needs to have the connection field set. The returned blowup graph and subgraph will also have the connection field set, but not the curveClasses field.  (It will be calculated automatically on demand via GKM_second_homology()).  Mathematically, this follows [GZ01, section 2.2.1].\n\nwarning: Warning\nThis will build an undirected graph. Behaviour with directed graphs as input is not tested.\n\nExamples\n\njulia> G = projective_space(GKM_graph, 3) # 3-dimensional projective space\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\n\njulia> S = gkm_subgraph_from_vertices(G, [1, 2]) # we take the subgraph of two vertices, it corresponds to a line\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n\njulia> blowupSub = blow_up(S) # blowup of P3 along the line S\nGKM subgraph of:\nGKM graph with 6 nodes, valency 3 and axial function:\n[1>4] -> [1>3] => (0, 0, -1, 1)\n[2>3] -> [1>3] => (-1, 1, 0, 0)\n[2>4] -> [1>4] => (-1, 1, 0, 0)\n[2>4] -> [2>3] => (0, 0, -1, 1)\n3 -> [1>3] => (-1, 0, 1, 0)\n3 -> [2>3] => (0, -1, 1, 0)\n4 -> [1>4] => (-1, 0, 0, 1)\n4 -> [2>4] => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 4 nodes, valency 2 and axial function:\n[1>4] -> [1>3] => (0, 0, -1, 1)\n[2>3] -> [1>3] => (-1, 1, 0, 0)\n[2>4] -> [1>4] => (-1, 1, 0, 0)\n[2>4] -> [2>3] => (0, 0, -1, 1)\n\njulia> Spoint = gkm_subgraph_from_vertices(G, [1]) # we take the subgraph of one vertex that is an invariant point\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 1 nodes, valency 0 and axial function:\n\njulia> blowupPt = blow_up(Spoint) # blowup of P3 at a point\nGKM subgraph of:\nGKM graph with 6 nodes, valency 3 and axial function:\n[1>3] -> [1>2] => (0, -1, 1, 0)\n[1>4] -> [1>2] => (0, -1, 0, 1)\n[1>4] -> [1>3] => (0, 0, -1, 1)\n2 -> [1>2] => (-1, 1, 0, 0)\n3 -> [1>3] => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> [1>4] => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 3 nodes, valency 2 and axial function:\n[1>3] -> [1>2] => (0, -1, 1, 0)\n[1>4] -> [1>2] => (0, -1, 0, 1)\n[1>4] -> [1>3] => (0, 0, -1, 1)\n\n\n\n\n\n","category":"function"},{"location":"GKM/Operators/#Products","page":"Operators","title":"Products","text":"","category":"section"},{"location":"GKM/Operators/#Base.:*-Tuple{GKMtools.AbstractGKM_graph, GKMtools.AbstractGKM_graph}","page":"Operators","title":"Base.:*","text":"*(G1::AbstractGKM_graph, G2::AbstractGKM_graph; calculateCurveClasses::Bool=true, calculateConnection::Bool=true) -> AbstractGKM_graph\n\nIt constructs the product of two GKM graphs.\n\nExamples\n\njulia> G = generalized_gkm_flag(root_system(:A, 1))\nGKM graph with 2 nodes, valency 1 and axial function:\ns1 -> id => (-1, 1)\n\njulia> G*G\nGKM graph with 4 nodes, valency 2 and axial function:\ns1,id -> id,id => (-1, 1, 0, 0)\nid,s1 -> id,id => (0, 0, -1, 1)\ns1,s1 -> s1,id => (0, 0, -1, 1)\ns1,s1 -> id,s1 => (-1, 1, 0, 0)\n\n\nnote: Note\nThe character group is of type free mathbbQ-module if this holds for one of the two GKM graphs.\n\n\n\n\n\n","category":"method"},{"location":"GW/GW/#Equivariant-Gromov–Witten-invariants-of-GKM-graphs","page":"Gromov–Witten invariants","title":"Equivariant Gromov–Witten invariants of GKM graphs","text":"","category":"section"},{"location":"GW/GW/","page":"Gromov–Witten invariants","title":"Gromov–Witten invariants","text":"One of the main features of this package is to calculate equivariant Gromov-Witten invariants of GKM varieties X.","category":"page"},{"location":"GW/GW/","page":"Gromov–Witten invariants","title":"Gromov–Witten invariants","text":"Mathematical ingredients: The following mathematical ingredients are used in the package:","category":"page"},{"location":"GW/GW/","page":"Gromov–Witten invariants","title":"Gromov–Witten invariants","text":"The localization formula from [LS17] that expresses equivariant Gromov-Witten invariants in the form\n  GW^T_Xg=0mbeta() = sum_overrightarrowGamma GW^T_overrightarrowGamma\nwhere the sum is over certain decorated trees overrightarrowGamma mapping into the GKM graph of X, such that the edge multiplicities sum to the curve class betain H_2(XmathbbZ). Here, GW^T_overrightarrowGamma is a rational function in dimT many variables, i.e. an element of textFracH_T^*(textptmathbbQ).\nAn efficient way of enumerating trees with marked points and counting their automorphisms (inspired by [WROM86]).\nA way of enumerating all combination of edges with multiplicities in the GKM graph that sum to a given curve class betain H_2(XmathbbZ) (see supporting paper).","category":"page"},{"location":"GW/GW/#Integrating-on-the-moduli-space","page":"Gromov–Witten invariants","title":"Integrating on the moduli space","text":"","category":"section"},{"location":"GW/GW/#GKMtools.gromov_witten","page":"Gromov–Witten invariants","title":"GKMtools.gromov_witten","text":"gromov_witten(G::AbstractGKM_graph, beta::CurveClass_type, n_marks::Int64, P_input::EquivariantClass; show_bar::Bool = false) -> GW invariants\n\nIntegrate the class P_input over the moduli space overlinemathcalM_0n(Xbeta) of genus 0 stable maps to X in class betain H_2(XmathbbZ) with n_marks marked points. The result is an element of textFrac(H_T^*(textptmathbbQ)), i.e. a rational function in dim_mathbbC(T) many variables.\n\nnote: Note\nIf the underlying space is a (smooth projective) GKM variety then the output should in fact live in H_T^*(textptmathbbQ), so it should be  a polynomial in the dim_mathbbC(T) many variables.\n\nwarning: Warning\nThe GKM graph G must have a connection, as this datum is required by the localization formula [LS17].\n\nArguments\n\nG::AbstractGKM_graph: The GKM graph of the target GKM variety X.\nbeta::CurveClass_type: The (non-zero) curve class betain H_2(XmathbbZ) in which the image of the stable map should lie.  To produce beta, use functions like curve_class (see Curve Classes).\nP_input::EquivariantClass: The equivariant cohomology class on overlinemathcalM_0n(Xbeta) that is being integrated.  Use the functions ev, class_one, and Psi to produce this. These classes also support arithmetic using +, *, et cetera.\nshow_bar::Bool: If true, a progress bar will be displayed showing the estimated time until completion. This should be used for big examples.\nfast_mode::Bool: If the expected result of the computation is a number, this option will speed up the computation.\n\nwarning: Warning\nIf the expected result of the computation is not a number and fast_mode is true, the result will be a meaningless number.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> beta = curve_class(P2, Edge(1, 2));\n\njulia> gromov_witten(P2, beta, 1, ev(1, point_class(P2, 1)); show_bar=false)\n0\n\njulia> gromov_witten(P2, beta, 2, ev(1, point_class(P2, 1)) * ev(2, point_class(P2, 2)); show_bar=false)\n1\n\njulia> gromov_witten(P2, beta, 2, ev(1, point_class(P2, 1)) * ev(2, point_class(P2, 1)); show_bar=false, fast_mode=true)\n1\n\njulia> gromov_witten(P2, beta, 2, ev(1, point_class(P2, 1))^2 * ev(2, point_class(P2, 2)); show_bar=false)\nt1^2 - t1*t2 - t1*t3 + t2*t3\n\njulia> gromov_witten(P2, beta, 3, ev(1, point_class(P2, 1)) * ev(2, point_class(P2, 1)) * ev(3, point_class(P2, 3)); show_bar=false)\nt1 - t2\n\n\n\n\n\ngromov_witten(V::GKM_vector_bundle, beta::CurveClass_type, n_marks::Int64, P_input::EquivariantClass; show_bar::Bool = false, check_degrees::Bool = false)\n\nSame as before, but taking the total space of a GKM vector bundle as input.\n\n\n\n\n\ngromov_witten(V::GKM_vector_bundle, beta::CurveClass_type, n_marks::Int64, P_input::EquivariantClass; show_bar::Bool = false, check_degrees::Bool = false)\n\nSame as before, but taking the total space of a GKM vector bundle as input.\n\n\n\n\n\n","category":"function"},{"location":"GW/GW/#Cohomology-classes-on-the-moduli-space","page":"Gromov–Witten invariants","title":"Cohomology classes on the moduli space","text":"","category":"section"},{"location":"GW/GW/#GKMtools.ev","page":"Gromov–Witten invariants","title":"GKMtools.ev","text":"ev(j::Int64, cc) -> EquivariantClass\n\nReturn the equivariant cohomology class on overlinemathcalM_0n(Xbeta) that is given by pulling back the cohomology class cc on X along the evaluation map at the j-th point: textev_jcolon overlinemathcalM_0n(Xbeta)rightarrow X.\n\nExample\n\njulia> G24 = grassmannian(GKM_graph, 2, 4);\n\njulia> e1 = ev(1, point_class(G24, 1));\n\njulia> e2 = ev(2, first_chern_class(G24));\n\njulia> e3 = ev(3, poincare_dual(gkm_subgraph_from_vertices(G24, [1, 2])));\n\njulia> beta = curve_class(G24, Edge(1, 2));\n\njulia> gromov_witten(G24, beta, 3, e1 * e2 * e3; show_bar=false)\n4\n\n\n\n\n\n","category":"function"},{"location":"GW/GW/#GKMtools.class_one","page":"Gromov–Witten invariants","title":"GKMtools.class_one","text":"class_one() -> EquivariantClass\n\nReturn the cohomology class 1 on overlinemathcalM_0n(Xbeta).\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> beta = curve_class(P2, Edge(1, 2));\n\njulia> gromov_witten(P2, beta, 2, ev(1, point_class(P2, 1)) * ev(2, point_class(P2, 2)); show_bar=false)\n1\n\njulia> gromov_witten(P2, beta, 2, ev(1, point_class(P2, 1)) * ev(2, point_class(P2, 2)) * class_one(); show_bar=false)\n1\n\njulia> gromov_witten(P2, beta, 0, class_one(); show_bar=false)\n0\n\n\n\n\n\n","category":"function"},{"location":"GW/GW/#GKMtools.Psi","page":"Gromov–Witten invariants","title":"GKMtools.Psi","text":"Psi(a) -> EquivariantClass\n\nFor each index i such that 0le i le n, there is a line bundle on overlinemathcalM_0n(Xbeta) such that the fiber at a moduli point is the cotangent bundle of the curve at the i^mathrmth marked point.  We denote by psi_i the first Chern class of this line bundle. In order to compute invariants involving psi_1^a_1cdots psi_n^a_n, for some nonnegative integers  a_1ldots a_n, we write Psi(a_1,...,a_n)\n\nExample\n\nLet G be the GKM graph of the Hirzebruch surface mathbbP(mathcalO_mathbbP^1(0) oplus mathcalO_mathbbP^1(1)), let beta the class of the fiber. The invariant\n\nint_overlineM_02(G beta)mathrmev_1^*(mathrmpt)cdotpsi_1^0psi_2 = -1\n\ncan be computed as following.\n\njulia> G = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 1));\n\njulia> P = ev(1, point_class(G, 1)) * Psi(0,1);\n\njulia> beta = curve_class(G, \"1\", \"4\"); # beta is a fiber of the map G -> P^1\n\njulia> gromov_witten(G, beta, 2, P; show_bar=false)\n-1\n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"Misc/Misc/","page":"Miscellaneous","title":"Miscellaneous","text":"In this section we collect functions that are useful for GKM graphs, but that do not belong to GKM theory.","category":"page"},{"location":"Misc/Misc/#Smoothness-of-Schubert-varieties","page":"Miscellaneous","title":"Smoothness of Schubert varieties","text":"","category":"section"},{"location":"Misc/Misc/#GKMtools.isregular_word","page":"Miscellaneous","title":"GKMtools.isregular_word","text":"isregular_word(w::WeylGroupElem) -> Bool\n\nGiven a Weyl group element w, this function returns true if and only if the Bruhat graph of w is regular. That is, all vertices  have the same number of incident edges. We implemented [BP05, Lemma 5.7].  Note that the Schubert variety given by w is rationally smooth if and only if the Bruhat graph of w is regular. \n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#GKMtools.issmooth_schubert_at_v","page":"Miscellaneous","title":"GKMtools.issmooth_schubert_at_v","text":"issmooth_schubert_at_v(v::WeylGroupElem, w::WeylGroupElem) -> Bool\n\nGiven a Weyl group element w, this function returns true if and only if the Schubert variety given by w is smooth at the point given by v.  We implemented [Kum96, Theorem 5.5], see also [BL00, 7.2.1 Theorem].\n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#GKMtools.issmooth_schubert","page":"Miscellaneous","title":"GKMtools.issmooth_schubert","text":"issmooth_schubert(w::WeylGroupElem) -> Bool\n\nCheck if the Schubert variety given by w is smooth at the point given by the identity element. This is equivalent to the Schubert variety be smooth.\n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#Kazhdan-Lusztig-polynomials","page":"Miscellaneous","title":"Kazhdan-Lusztig polynomials","text":"","category":"section"},{"location":"Misc/Misc/#GKMtools.R_polynomial","page":"Miscellaneous","title":"GKMtools.R_polynomial","text":"R_polynomial(v::WeylGroupElem, w::WeylGroupElem) -> ZZPolyRingElem\n\nGiven two Weyl group elements v,w, with v≤w this function returns the R-polynomial of v,w in the polynomial ring mathbbZq.  See [BL00, Section 6.1].\n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#GKMtools.kazhdan_lusztig","page":"Miscellaneous","title":"GKMtools.kazhdan_lusztig","text":"kazhdan_lusztig(v::WeylGroupElem, w::WeylGroupElem) -> ZZPolyRingElem\n\nGiven two Weyl group elements v,w, with v≤w this function returns the Kazhdan-Lusztig polynomial of v,w in the polynomial ring mathbbZq.  See [BL00, Equation (6.1.8)].\n\n\n\n\n\n","category":"function"},{"location":"GW/SeidelElements/#Seidel-elements-/-Shift-operators","page":"Seidel Elements / Shift Operators","title":"Seidel elements / Shift operators","text":"","category":"section"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"This section deals with certain equivariant Gromov–Witten invariants on Seidel spaces. The definition used in this package should be carefully compared to [Iri17, Section 3] and [MO19, Chapter 8] (shift operators). A (non-equivariant) symplectic account can be found in [MS12, Section 11.4] (Seidel representation).","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"Let X be a (smooth projective) GKM variety with torus action by T, and let iotacolon  mathbbC^times rightarrow T be a group homomorphism. This gives rise to the X-bundle picolon S_Xrightarrow mathbbP^1, where S_X is the Seidel space associated to (X iota). Recall that S_X is a GKM space with respect to widehatT= TtimesmathbbC^times, where the extra copy of mathbbC^times acts by rotating the base mathbbP^1.","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"Let (e_i) and (e^i) be dual bases of H_T^*(XmathbbQ) with respect to the T-equivariant Poincaré pairing on X. Note also that we have a H_T^*(textptmathbbQ)-linear pushforward map (i_infty)_*colon H_T^*(XmathbbQ) rightarrow H_widehatT^*(S_XmathbbQ) raising degree by one.","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"Finally, let H_2^textsec(S_XmathbbZ) be the set of effective section curve classes in S_X, i.e., effective curve classes that project to mathbbP^1 under picolon S_XrightarrowmathbbP^1. The additive group H_2^textsec(S_XmathbbZ) is an H_2^texteff(XmathbbZ)-torsor, so after picking some beta_0in H_2^textsec(S_XmathbbZ) there is an identification rcolon H_2^textsec(S_XmathbbZ)stackrelconglongrightarrow H_2^texteff(XmathbbZ) that sends beta_0 to 0.","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"The (equivariant) Seidel element associated to iota is","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"  mathcalS(iota) = sum_betain H_2^textsec(S_XmathbbZ) leftGW^widehatT_01beta((i_infty)_*(e_i))right_hatt = 0 e^i q^r(beta) in QH_T^*(X)","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"where hatt is the equivariant parameter for the extra mathbbC^times in widehatT.","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"note: Note\nLet Lambda= textHom(mathbbC^times T) be the cocharacter lattice of T. It is a key property of the equivariant Seidel elements that the map  mathcalScolon Lambda rightarrow QH_T^*(X)^timesis a group homomorphism, where QH_T^*(X)^times is endowed with the equivariant quantum product.","category":"page"},{"location":"GW/SeidelElements/#GKMtools.Seidel_element","page":"Seidel Elements / Shift Operators","title":"GKMtools.Seidel_element","text":"Seidel_element(G::AbstractGKM_graph, w::AbstractAlgebra.Generic.FreeModuleElem{R}, cMax::Int64) where R<:GKM_weight_type\n\nReturn the Seidel element on G associated to the homomorphism iotacolon mathbbC^timesrightarrow T defined by w. This calculates the contribution of curve classes with Chern number at most cMax.\n\nwarning: Warning\nThis requires is_strictly_NEF(G) == true as otherwise there might be infinitely many contributing curve classes.\n\nCurve classes\n\nThe curve classes of the Seidel space are represented as (beta n) where beta is a curve class of X and the integer n is the degree of the curve projected along S_XrightarrowmathbbP^1.\n\nThe inclusions of the fibre X over 0 and infty simply send beta mapsto (beta0).\nEach fixed point vin X^T gives an invariant curve that is a section of S_Xrightarrow mathbbP^1.  Its curve class is (beta_v1), where the beta_v are only uniquely determined up to an overall constant.  The Seidel space used in this function is normalized such that beta_1=0, where 1 is the fixed point represented by the GKM graph vertex with index 1.\n\nExample\n\njulia> P1 = projective_space(GKM_graph, 1);\n\njulia> t1, t2 = gens(P1.M);\n\njulia> cMax = 6;\n\njulia> S1 = Seidel_element(P1, t1, cMax)\n(0, -t1 + t2) q^(-1)\n\njulia> S2 = Seidel_element(P1, t2, cMax)\n(t1 - t2, 0) q^(0)\n\njulia> S3 = Seidel_element(P1, t1+t2, cMax)\n(1, 1) q^(0)\n\njulia> S1 * S2 == S3\ntrue\n\njulia> S4 = Seidel_element(P1, -2*t1, cMax)\n(t1^2 - 2*t1*t2 + t2^2, 0) q^(0)\n + (1, 1) q^(1)\n\njulia> S4 * S1 * S1\n(1, 1) q^(0)\n\n\n\n\n\n","category":"function"},{"location":"#GKMtools.jl","page":"Home","title":"GKMtools.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package is work in progress. It offers support for calculations involving GKM varieties, including their equivariant Gromov-Witten invariants. It requires Oscar. See https://www.oscar-system.org/install/.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It comes with the supporting article: (Work in Progress...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is divided in two parts. The first one deals with foundational material on GKM varieties in general. The second part is dedicated to the computation of equivariant Gromov–Witten invariants, equivariant quantum cohomology and equivariant Seidel elements (shift operators).","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the github page for installation instructions. This version is version 0.11.1.","category":"page"}]
}
