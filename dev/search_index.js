var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"S. Billey and V. Lakshmibai. Singular loci of Schubert varieties. Vol. 182 of Progress in Mathematics (Birkhäuser Boston, Inc., Boston, MA, 2000); p. xii+251.\n\n\n\nS. Billey and A. Postnikov. Smoothness of Schubert varieties via patterns in root               subsystems. Adv. in Appl. Math. 34, 447–466 (2005).\n\n\n\nI. Charton and L. Kessler. Monotone Symplectic Six-Manifolds that admit a Hamiltonian GKM Action are diffeomorphic to Smooth Fano Threefolds (2023), https://arxiv.org/abs/2308.10541.\n\n\n\nD. A. Cox and S. Katz. Mirror symmetry and algebraic geometry. Vol. 68 of Mathematical Surveys and Monographs (American Mathematical Society, Providence, RI, 1999); p. xxii+469.\n\n\n\nO. Goertsches, P. Konstantis and L. Zoller. Realization of GKM fibrations and new examples of               Hamiltonian non-Kähler actions. Compos. Math. 159, 2149–2190 (2023).\n\n\n\nO. Goertsches, P. Konstantis and L. Zoller. Low-dimensional GKM theory. In: Group actions and equivariant cohomology, Vol. 808 of Contemp. Math. (Amer. Math. Soc., [Providence], RI, 2024); pp. 113–146.\n\n\n\nM. Goresky, R. Kottwitz and R. MacPherson. Equivariant cohomology, Koszul duality, and the localization               theorem. Invent. Math. 131, 25–83 (1998).\n\n\n\nV. Guillemin and C. Zara. Equivariant de Rham theory and graphs. In: Surveys in differential geometry, Vol. 7 of Surv. Differ. Geom. (Int. Press, Somerville, MA, 2000); pp. 221–257.\n\n\n\nV. Guillemin and C. Zara. 1-skeleta, Betti numbers, and equivariant cohomology. Duke Math. J. 107, 283–349 (2001).\n\n\n\nV. Guillemin, S. Sabatini and C. Zara. Cohomology of GKM fiber bundles. J. Algebraic Combin. 35, 19–59 (2012).\n\n\n\nH. Iritani. Shift operators and toric mirror theorem. Geom. Topol. 21, 315–343 (2017).\n\n\n\nS. Kumar. The nil Hecke ring and singularity of Schubert varieties. Invent. Math. 123, 471–506 (1996).\n\n\n\nC.-C. M. Liu and A. Sheshmani. Equivariant Gromov–Witten invariants of algebraic GKM               manifolds. SIGMA Symmetry Integrability Geom. Methods Appl. 13, Paper No. 048, 21 (2017).\n\n\n\nD. Maulik and A. Okounkov. Quantum groups and quantum cohomology. Astérisque, ix+209 (2019).\n\n\n\nD. McDuff and D. Salamon. J-holomorphic curves and symplectic topology. Second Edition, Vol. 52 of American Mathematical Society Colloquium Publications (American Mathematical Society, Providence, RI, 2012); p. xiv+726.\n\n\n\nD. Mumford, J. Fogarty and F. Kirwan. Geometric invariant theory. Third Edition, Vol. 34 of Ergebnisse der Mathematik und ihrer Grenzgebiete (2) [Results               in Mathematics and Related Areas (2)] (Springer-Verlag, Berlin, 1994); p. xiv+292.\n\n\n\nR. A. Wright, B. Richmond, A. Odlyzko and B. D. McKay. Constant time generation of free trees. SIAM J. Comput. 15, 540–548 (1986).\n\n\n\n","category":"page"},{"location":"GKM/STDconstructions/#Standard-Constructions","page":"Standard Constructions","title":"Standard Constructions","text":"","category":"section"},{"location":"GKM/STDconstructions/","page":"Standard Constructions","title":"Standard Constructions","text":"In this section we present some functions that allow the construction of famous GKM graphs.","category":"page"},{"location":"GKM/STDconstructions/#Generalized-Flags-Varieties","page":"Standard Constructions","title":"Generalized Flags Varieties","text":"","category":"section"},{"location":"GKM/STDconstructions/#GKMtools.generalized_gkm_flag","page":"Standard Constructions","title":"GKMtools.generalized_gkm_flag","text":"generalized_gkm_flag(R::RootSystem, S::Vector{RootSpaceElem}) -> GKM_graph\n\nGiven a root system R and a subset S of the set of simple roots, it constructs the  GKM graph of the generalized flag variety GP. Here G is the simply-connected complex Lie group  with root system R, and P is the parabolic subgroup with root system S. If S is empty, it construct GB where B is a Borel subgroup. The vertices of GP correspond to the cosets WW_P where W (resp., W_P) is the Weyl group of G (resp., P). The label of a vertex is the unique element of minimal length in the corresponding coset.\n\nnote: Note\nThe character group is of type free mathbbZ-module if R is of type A B C D G. It is a free mathbbQ-module if R is of type E or F.\n\nwarning: Warning\nComputing this function with root systems of very large Weyl groups may be slow.\n\nExamples\n\njulia> A1xA1 = root_system([(:A, 1), (:A, 1)])\nRoot system of rank 2\n  of type A1 x A1\n\njulia> generalized_gkm_flag(A1xA1)\nGKM graph with 4 nodes, valency 2 and axial function:\ns1 -> id => (-1, 1, 0, 0)\ns2 -> id => (0, 0, -1, 1)\ns1*s2 -> s1 => (0, 0, -1, 1)\ns1*s2 -> s2 => (-1, 1, 0, 0)\n\njulia> RC3 = root_system(:C, 3)\nRoot system of rank 3\n  of type C3\n\njulia> gp1 = generalized_gkm_flag(RC3);\n\njulia> rank_torus(gp1)\n3\n\njulia> R = root_system([(:A, 1), (:G, 2)])\nRoot system of rank 3\n  of type A1 x G2\n\njulia> S = [simple_roots(R)[3]];\n\njulia> gp2 = generalized_gkm_flag(R, S);\n\njulia> rank_torus(gp2)\n5\n\n\n\n\n\n\ngeneralized_gkm_flag(R::RootSystem; indices_of_S) -> GKM_graph\n\nSame as before, but indicating the indices of the roots in S instead of the roots itself.\n\nExamples\n\njulia> R = root_system(matrix(ZZ, [2 -1 -2; -1 2 0; -1 0 2]))\nRoot system of rank 3\n  of type C3 (with non-canonical ordering of simple roots)\n\njulia> gp1 = generalized_gkm_flag(R, 2:3);\n\njulia> valency(gp1)\n7\n\njulia> gp2 = generalized_gkm_flag(R, [1,2]);\n\njulia> rank_torus(gp2)\n3\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#GKMtools.flag_variety","page":"Standard Constructions","title":"GKMtools.flag_variety","text":"flag_variety(::Type{GKM_graph}, s::Vector{Int64}) -> GKM_graph{ZZRingElem}\n\nConstruct the GKM graph of the variety of flags of mathbbC^n. The dimensions of quotients are expressed by the array s. The labels represent the vectors generating the flags. For example, if s=121, the string 213 corresponds to the flag:\n\n0subset langle e_2 rangle subset langle e_2 e_1 e_3 rangle subset langle e_2 e_1 e_3 e_4 rangle=mathbbC^4\n\nnote: Note\nThis function is faster than generalized_gkm_flag(root_system(:A, n-1), S), but the results are isomorphic.\n\nExamples\n\njulia> flag_variety(GKM_graph, [1,3])\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\n\njulia> flag_variety(GKM_graph, [2,1])\nGKM graph with 3 nodes, valency 2 and axial function:\n13 -> 12 => (0, -1, 1)\n23 -> 12 => (-1, 0, 1)\n23 -> 13 => (-1, 1, 0)\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#GKMtools.grassmannian","page":"Standard Constructions","title":"GKMtools.grassmannian","text":"grassmannian(::Type{gkm_graph}, k::Int, n::Int) -> GKM_graph{ZZRingElem}\n\nConstruct the Grassmann variety of k-planes in the complex vector space of dimension n.\n\nExamples\n\njulia> grassmannian(GKM_graph, 2, 4)\nGKM graph with 6 nodes, valency 4 and axial function:\n13 -> 12 => (0, -1, 1, 0)\n14 -> 12 => (0, -1, 0, 1)\n14 -> 13 => (0, 0, -1, 1)\n23 -> 12 => (-1, 0, 1, 0)\n23 -> 13 => (-1, 1, 0, 0)\n24 -> 12 => (-1, 0, 0, 1)\n24 -> 14 => (-1, 1, 0, 0)\n24 -> 23 => (0, 0, -1, 1)\n34 -> 13 => (-1, 0, 0, 1)\n34 -> 14 => (-1, 0, 1, 0)\n34 -> 23 => (0, -1, 0, 1)\n34 -> 24 => (0, -1, 1, 0)\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Oscar.projective_space","page":"Standard Constructions","title":"Oscar.projective_space","text":"projective_space(::Type{gkm_graph}, d::Int)\n\nConstruct the projective space of dimension d.\n\nExamples\n\njulia> projective_space(GKM_graph, 2)\nGKM graph with 3 nodes, valency 2 and axial function:\n2 -> 1 => (-1, 1, 0)\n3 -> 1 => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Generalized-Schubert-Varieties","page":"Standard Constructions","title":"Generalized Schubert Varieties","text":"","category":"section"},{"location":"GKM/STDconstructions/#GKMtools.get_bruhat_order_of_generalized_flag","page":"Standard Constructions","title":"GKMtools.get_bruhat_order_of_generalized_flag","text":"get_bruhat_order_of_generalized_flag(R::RootSystem, S::Vector{RootSpaceElem}; descending::Bool=true) -> BruhatOrder\n\nIt returns the Bruhat order of the generalized flag variety given by the root system R with the subset of simple roots given by S. See generalized_gkm_flag. If descending is true, the Bruhat order is given from the elements of maximal length to the smallest.\n\nExamples\n\njulia> R = root_system(:A, 3);\n\njulia> S = simple_roots(R);\n\njulia> get_bruhat_order_of_generalized_flag(R, S[1:2])\nBruhat order in descending order:\nLength: 3\n  s1*s2*s3 => [\"s2*s3\"]\nLength: 2\n  s2*s3 => [\"s3\"]\nLength: 1\n  s3 => [\"id\"]\nLength: 0\n  id\n\n\n\n\n\n\nget_bruhat_order_of_generalized_flag(R::RootSystem, indices_of_S; descending::Bool=true) -> BruhatOrder\n\nSame as before, but indicating the indices of the roots in S instead of the roots itself.\n\nExamples\n\njulia> R = root_system(:A, 3);\n\njulia> get_bruhat_order_of_generalized_flag(R, [1]; descending = false)\nBruhat order in ascending order:\nLength: 0\n  id => [\"s2\", \"s3\"]\nLength: 1\n  s2 => [\"s1*s2\", \"s3*s2\", \"s2*s3\"]\n  s3 => [\"s3*s2\", \"s2*s3\"]\nLength: 2\n  s2*s3 => [\"s2*s3*s2\", \"s1*s2*s3\"]\n  s1*s2 => [\"s1*s3*s2\", \"s1*s2*s3\"]\n  s3*s2 => [\"s1*s3*s2\", \"s2*s3*s2\"]\nLength: 3\n  s1*s2*s3 => [\"s1*s2*s3*s2\"]\n  s2*s3*s2 => [\"s2*s1*s3*s2\", \"s1*s2*s3*s2\"]\n  s1*s3*s2 => [\"s2*s1*s3*s2\", \"s1*s2*s3*s2\"]\nLength: 4\n  s2*s1*s3*s2 => [\"s1*s2*s1*s3*s2\"]\n  s1*s2*s3*s2 => [\"s1*s2*s1*s3*s2\"]\nLength: 5\n  s1*s2*s1*s3*s2\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#GKMtools.generalized_gkm_schubert","page":"Standard Constructions","title":"GKMtools.generalized_gkm_schubert","text":"generalized_gkm_schubert(R::RootSystem, indices_of_S::Vector{RootSpaceElem}, pt::String) -> GKM_subgraph\n\nLet G be the generalized flag variety given by the root system R with the subset of simple roots given by S. See generalized_gkm_flag. This functions returns the subgraph of the variety G given by all Schubert cells corresponding to the points less or equal to pt in the Bruhat order.\n\nExamples\n\njulia> R = root_system(:B, 2);\n\njulia> generalized_gkm_schubert(R, \"s1*s2\")\nGKM subgraph of:\nGKM graph with 8 nodes, valency 4 and axial function:\ns1 -> id => (-1, 1)\ns2*s1 -> s1 => (0, -1)\ns1*s2*s1 -> id => (-1, 0)\ns1*s2*s1 -> s2*s1 => (-1, 1)\ns2 -> id => (0, -1)\ns2 -> s2*s1 => (1, 1)\ns1*s2 -> s1 => (-1, 0)\ns1*s2 -> s1*s2*s1 => (1, 1)\ns1*s2 -> s2 => (-1, 1)\ns2*s1*s2 -> id => (-1, -1)\ns2*s1*s2 -> s2*s1 => (-1, 0)\ns2*s1*s2 -> s1*s2 => (0, -1)\ns1*s2*s1*s2 -> s1 => (-1, -1)\ns1*s2*s1*s2 -> s1*s2*s1 => (0, -1)\ns1*s2*s1*s2 -> s2 => (-1, 0)\ns1*s2*s1*s2 -> s2*s1*s2 => (-1, 1)\nSubgraph:\nGKM graph with 4 nodes, valency 2 and axial function:\ns1 -> id => (-1, 1)\ns2 -> id => (0, -1)\ns1*s2 -> s1 => (-1, 0)\ns1*s2 -> s2 => (-1, 1)\n\nAs before, the subset S can be a subset of simple roots or a subset of indices.\n\njulia> generalized_gkm_schubert(R, [1], \"s2\")\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\ns2 -> id => (0, -1)\ns1*s2 -> id => (-1, 0)\ns1*s2 -> s2 => (-1, 1)\ns2*s1*s2 -> id => (-1, -1)\ns2*s1*s2 -> s2 => (-1, 0)\ns2*s1*s2 -> s1*s2 => (0, -1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\ns2 -> id => (0, -1)\n\njulia> S = simple_roots(R);\n\njulia> generalized_gkm_schubert(R, [S[2]], \"s1\")\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\ns1 -> id => (-1, 1)\ns2*s1 -> id => (-1, -1)\ns2*s1 -> s1 => (0, -1)\ns1*s2*s1 -> id => (-1, 0)\ns1*s2*s1 -> s1 => (-1, -1)\ns1*s2*s1 -> s2*s1 => (-1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\ns1 -> id => (-1, 1)\n\n\n\n\n\n\ngeneralized_gkm_schubert(R::RootSystem, indices_of_S::Union{UnitRange{Int64}, Vector{Int64}}, pt::String)  -> AbstractGKM_subgraph\n\n\n\n\n\ngeneralized_gkm_schubert(R::RootSystem, pt::String) -> AbstractGKM_subgraph\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#GKMtools.bott_samelson","page":"Standard Constructions","title":"GKMtools.bott_samelson","text":"bott_samelson(S::Vector{RootSpaceElem}; printEdges::Bool = true)\n\nWe construct the Bott-Samelson desingularization of a Schubert variety given by S.\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Schubert-Classes","page":"Standard Constructions","title":"Schubert Classes","text":"","category":"section"},{"location":"GKM/STDconstructions/#Oscar.IntersectionTheory.schubert_class","page":"Standard Constructions","title":"Oscar.IntersectionTheory.schubert_class","text":"schubert_class(schubert::AbstractGKM_subgraph, BO::BruhatOrder, label::String)\n\nReturn the Poincare dual (as subvariety of the Schubert variety schubert) of the Schubert variety given by label.\n\nArguments\n\nschubert::AbstractGKM_subgraph: The Schubert variety given as GKM subgraph object of the corresponding generalized partial flag variety (as returned by generalized_gkm_schubert).\nBO::BruhatOrder: The Bruhat order on the generalized partial flag variety (as returned by get_bruhat_order_of_generalized_flag).\nlabel:String: The label of the Weyl group element or coset defining the Schubert variety as subvariety of the generalized partial flag variety.\n\nExample\n\njulia> R = root_system(:A, 3);\n\njulia> S = simple_roots(R);\n\njulia> BO = get_bruhat_order_of_generalized_flag(R, S[1:1]);\n\njulia> schubert = generalized_gkm_schubert(R, S[1:1], \"s1*s2*s3\")\nGKM subgraph of:\nGKM graph with 12 nodes, valency 5 and axial function:\ns2 -> id => (0, -1, 1, 0)\ns1*s2 -> id => (-1, 0, 1, 0)\ns1*s2 -> s2 => (-1, 1, 0, 0)\ns3*s2 -> s2 => (0, 0, -1, 1)\ns1*s3*s2 -> s1*s2 => (0, 0, -1, 1)\ns1*s3*s2 -> s3*s2 => (-1, 1, 0, 0)\ns2*s1*s3*s2 -> s1*s2 => (0, -1, 0, 1)\ns2*s1*s3*s2 -> s1*s3*s2 => (0, -1, 1, 0)\ns1*s2*s1*s3*s2 -> s2 => (-1, 0, 0, 1)\ns1*s2*s1*s3*s2 -> s3*s2 => (-1, 0, 1, 0)\ns1*s2*s1*s3*s2 -> s2*s1*s3*s2 => (-1, 1, 0, 0)\ns2*s3*s2 -> id => (0, -1, 0, 1)\ns2*s3*s2 -> s3*s2 => (0, -1, 1, 0)\ns2*s3*s2 -> s2*s1*s3*s2 => (1, 0, -1, 0)\ns1*s2*s3*s2 -> id => (-1, 0, 0, 1)\ns1*s2*s3*s2 -> s1*s3*s2 => (-1, 0, 1, 0)\ns1*s2*s3*s2 -> s1*s2*s1*s3*s2 => (0, 1, -1, 0)\ns1*s2*s3*s2 -> s2*s3*s2 => (-1, 1, 0, 0)\ns3 -> id => (0, 0, -1, 1)\ns3 -> s3*s2 => (0, 1, 0, -1)\ns3 -> s1*s3*s2 => (1, 0, 0, -1)\ns2*s3 -> s2 => (0, -1, 0, 1)\ns2*s3 -> s2*s1*s3*s2 => (1, 0, 0, -1)\ns2*s3 -> s2*s3*s2 => (0, 0, 1, -1)\ns2*s3 -> s3 => (0, -1, 1, 0)\ns1*s2*s3 -> s1*s2 => (-1, 0, 0, 1)\ns1*s2*s3 -> s1*s2*s1*s3*s2 => (0, 1, 0, -1)\ns1*s2*s3 -> s1*s2*s3*s2 => (0, 0, 1, -1)\ns1*s2*s3 -> s3 => (-1, 0, 1, 0)\ns1*s2*s3 -> s2*s3 => (-1, 1, 0, 0)\nSubgraph:\nGKM graph with 6 nodes, valency 3 and axial function:\ns2 -> id => (0, -1, 1, 0)\ns1*s2 -> id => (-1, 0, 1, 0)\ns1*s2 -> s2 => (-1, 1, 0, 0)\ns3 -> id => (0, 0, -1, 1)\ns2*s3 -> s2 => (0, -1, 0, 1)\ns2*s3 -> s3 => (0, -1, 1, 0)\ns1*s2*s3 -> s1*s2 => (-1, 0, 0, 1)\ns1*s2*s3 -> s3 => (-1, 0, 1, 0)\ns1*s2*s3 -> s2*s3 => (-1, 1, 0, 0)\n\njulia> schubert_class(schubert, BO, \"s1*s2\")\n(t3 - t4)*e[1] + (t2 - t4)*e[2] + (t1 - t4)*e[3]\n\njulia> schubert_class(schubert, BO, \"s1*s2*s3\")\ne[1] + e[2] + e[3] + e[4] + e[5] + e[6]\n\n\n\n\n\n\nschubert_class(schubert::AbstractGKM_graph, BO::BruhatOrder, v::Int64)\n\nLike above, but the Weyl group element is given by the index v corresponding to its index as vertex of the GKM graph on the flag variety containing the Schubert variety.\n\n\n\n\n\nschubert_class(flag::AbstractGKM_graph, BO::BruhatOrder, label::String)\n\nReturn the Poincare dual (as subvariety of the generalized partial flag variety flag) of the Schubert variety determined by label.\n\nArguments\n\nflag::AbstractGKM_graph: The generalized partial flag variety (as returned by generalized_gkm_flag).\nBO::BruhatOrder: The Bruhat order on the generalized partial flag variety (as returned by get_bruhat_order_of_generalized_flag).\nlabel:String: The label of the Weyl group element or coset defining the Schubert variety as subvariety of the generalized partial flag variety.\n\nExample\n\njulia> R = root_system(:G, 2);\n\njulia> BO = get_bruhat_order_of_generalized_flag(R);\n\njulia> flag = generalized_gkm_flag(R);\n\njulia> schubert_class(flag, BO, \"s2*s1*s2*s1*s2\")\n(-t2 + t3)*e[1] + (-t1 - t2 + 2*t3)*e[2] + (t1 - 2*t2 + t3)*e[3] + (-t1 + t3)*e[4] + (t1 - t2)*e[5] + (-t2 + t3)*e[7] + (-t1 - t2 + 2*t3)*e[8] + (t1 - 2*t2 + t3)*e[9] + (-t1 + t3)*e[10] + (t1 - t2)*e[11]\n\n\n\n\n\n\nschubert_class(flag::AbstractGKM_graph, BO::BruhatOrder, v::Int64)\n\nLike above, but the Weyl group element is given by the index v corresponding to its index as vertex of the GKM graph on the Schubert variety.\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Oscar.IntersectionTheory.schubert_classes","page":"Standard Constructions","title":"Oscar.IntersectionTheory.schubert_classes","text":"schubert_classes(schubert::AbstractGKM_subgraph, BO::BruhatOrder)\n\nReturn all Schubert classes on the given generalized Schubert variety. The i-th row in the returned matrix is the Schubert class of the Weyl group element (or coset) corresponding to the i-th vertex of the given Schubert variety.\n\nArguments\n\nschubert::AbstractGKM_subgraph: The Schubert variety given as GKM subgraph of its generalized partial flag variety (as returned by generalized_gkm_schubert).\nBO::BruhatOrder: The Bruhat order for the generalized partial flag variety containing the Schubert variety (as returned by get_bruhat_order_of_generalized_flag).\n\nExamples\n\nSchubert classes on the Schubert variety overlineX_s_1s_2s_3subset SL_4P_1:\n\njulia> R = root_system(:A, 2);\n\njulia> S = simple_roots(R);\n\njulia> schubert = generalized_gkm_schubert(R, S[1:1], \"s1*s2\");\n\njulia> BO = get_bruhat_order_of_generalized_flag(R, S[1:1]);\n\njulia> schubert_classes(schubert, BO)\n3×3 Matrix{QQMPolyRingElem}:\n t1*t2 - t1*t3 - t2*t3 + t3^2  0        0\n t1 - t3                       t1 - t2  0\n 1                             1        1\n\n\n\n\n\nschubert_classes(flag::AbstractGKM_graph, BO::BruhatOrder)\n\nReturn all Schubert classes on the given generalized partial flag variety. The i-th row in the returned matrix is the Schubert class of the Weyl group element (or coset) corresponding to the i-th vertex of the given partial flag variety.\n\nArguments\n\nflag::AbstractGKM_graph: The generalized partial flag variety (as returned by generalized_gkm_flag).\nBO::BruhatOrder: The Bruhat order for the generalized partial flag variety containing the Schubert variety (as returned by get_bruhat_order_of_generalized_flag).\n\nExample\n\njulia> R = root_system(:A, 2);\n\njulia> BO = get_bruhat_order_of_generalized_flag(R);\n\njulia> flag = generalized_gkm_flag(R);\n\njulia> schubert_classes(flag, BO)\n6×6 Matrix{QQMPolyRingElem}:\n t1^2*t2 - t1^2*t3 - t1*t2^2 + t1*t3^2 + t2^2*t3 - t2*t3^2  0                             0        0  0                             0\n t1*t2 - t1*t3 - t2*t3 + t3^2                               t1*t2 - t1*t3 - t2*t3 + t3^2  0        0  0                             0\n t1 - t3                                                    t1 - t3                       t1 - t2  0  t1 - t2                       0\n 1                                                          1                             1        1  1                             1\n t1^2 - t1*t2 - t1*t3 + t2*t3                               0                             0        0  t1^2 - t1*t2 - t1*t3 + t2*t3  0\n t1 - t3                                                    t2 - t3                       0        0  t1 - t3                       t2 - t3\n\n\n\n\n\n","category":"function"},{"location":"GKM/STDconstructions/#Toric-varieties","page":"Standard Constructions","title":"Toric varieties","text":"","category":"section"},{"location":"GKM/STDconstructions/#GKMtools.gkm_graph_of_toric","page":"Standard Constructions","title":"GKMtools.gkm_graph_of_toric","text":"gkm_graph_of_toric(v::NormalToricVariety) -> GKM_graph{ZZRingElem}\n\nConstruct the GKM graph of the (smooth, projective) toric variety v.\n\nExamples\n\njulia> P2 = projective_space(NormalToricVariety, 2)\nNormal toric variety\n\njulia> gkm_graph_of_toric(P2)\nGKM graph with 3 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1)\n3 -> 1 => (0, 1, -1)\n3 -> 2 => (-1, 1, 0)\n\njulia> F = hirzebruch_surface(NormalToricVariety, 3)\nNormal toric variety\n\njulia> gkm_graph_of_toric(F)\nGKM graph with 4 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1, 0)\n3 -> 2 => (3, 1, 0, -1)\n4 -> 1 => (0, 1, 3, -1)\n4 -> 3 => (-1, 0, 1, 0)\n\n\n\n\n\n","category":"function"},{"location":"GW/QH/#Quantum-Cohomology","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"","category":"section"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"Much of this can be found in [CK99, Chapter 8 and 9.3]. Let X be a (smooth projective) GKM variety. Its (small) equivariant quantum cohomology QH_T^*(X) is given additively by H_T^*(XmathbbQ)otimes widehatmathbbQH_2^texteff(XmathbbZ), where widehatmathbbQH_2^texteff(XmathbbZ) is the completion of the semigroup ring H_2^texteff(XmathbbZ) of effective curve classes. The element corresponding to betain H_2^texteff(XmathbbZ) is written as q^beta.","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"The H_T(textptmathbbQ)-module QH_T^*(X) is a commutative associative unital H_T(textptmathbbQ)-algebra via the (small) equivariant quantum product ast defined as follows. For every classes abcin H_T^*(XmathbbQ) we have","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"  langle a ast b c rangle = sum_betain H_2^texteff(XmathbbZ) GW^T_03beta(abc) cdot q^beta","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"where:","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"The equivariant Poincaré pairing is given by langle abrangle = int_X acup bin H_T^*(textptmathbbQ), where we use equivariant integration,\nWe denote by GW^T_03beta(abc)in H_T^*(textptmathbbQ) the equivariant Gromov–Witten invariant for X in class beta of genus 0 with 3 marked points.","category":"page"},{"location":"GW/QH/","page":"Quantum Cohomology","title":"Quantum Cohomology","text":"Note that setting all the equivariant parameters t_1dotst_dim_mathbbC(T) to zero recovers the standard (small, non-equivariant) quantum product.","category":"page"},{"location":"GKM/Connections/#Connections","page":"Connections","title":"Connections","text":"","category":"section"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"Let e be an directed edge prightarrow q, and let E_p (resp., E_q) be the set of all directed edges starting from p (resp., q). Following [GZ00], a connection along e is a bijection","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"nabla_ecolon E_p longrightarrow E_q","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"A connection nabla of a GKM graph G is a family of connections nabla = nabla_e _e in E, where E is the set of all edges of G, such that nabla_-e=nabla_e^-1.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"The connection is compatible with the axial function mathrmw of G if for all e in E_p, there exists an integer a depending on e and e such that","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"mathrmw(nabla_e(e)) = mathrmw(e) - a mathrmw(e)","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"If G is the GKM graph of a GKM variety X, then these integers a are the degrees of the equivariant line bundles into which TX splits when restricted to the invariant rational curve represented by e.","category":"page"},{"location":"GKM/Connections/#Existence-and-uniqueness-of-connections","page":"Connections","title":"Existence and uniqueness of connections","text":"","category":"section"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"Given a GKM graph G that comes from a GKM variety X, it always has a connection for the geometric reason sketched above. However, G may admit more than one connection.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"The following are sufficient conditions for the existence of a unique connection of G.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"The valency of G is at least 3 and G is 3-independent, i.e. the weights of every three edges starting at the same vertex are linearly independent.\nThe valency of G is at most 2.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"In those cases, the connection can be computed using get_connection.","category":"page"},{"location":"GKM/Connections/","page":"Connections","title":"Connections","text":"If neither of these two conditions hold and G is not the output of a standard construction, a choice of connection can be specified manually using set_connection!.","category":"page"},{"location":"GKM/Connections/#GKMtools.get_connection-Tuple{GKM_graph}","page":"Connections","title":"GKMtools.get_connection","text":"get_connection(G::GKM_graph; store::Bool = true) -> Union{Nothing, GKM_connection}\n\nIt returns the (unique) connection of the given GKM graph if it is 3-independent, or if it is 2-valent and 2-independent, or if it has been set manually. If none of the three cases hold, return nothing. If store is true, the new connection is stored inside G for later use\n\nnote: Note\nFor GKM graphs of valency at least 3 that are not 3-independent, a connection may still exist, although uniqueness is not guaranteed. Use get_any_connection to get any compatible connection if one exists.\n\nExample\n\nThe unique connection for mathbbP^n has nabla_(prightarrow q)(prightarrow r)=(qrightarrow r) for every triple of distinct vertices (p q r), and nabla_(prightarrow q)(prightarrow q)=(qrightarrow p) for every distinct vertices p and q.\n\njulia> G = projective_space(GKM_graph, 2)\nGKM graph with 3 nodes, valency 2 and axial function:\n2 -> 1 => (-1, 1, 0)\n3 -> 1 => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\n\njulia> C = get_connection(G)\nConnection:\n(Edge(3, 2), Edge(3, 1)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 3)) => Edge(1, 3)\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(3, 2), Edge(3, 2)) => Edge(2, 3)\n(Edge(1, 3), Edge(1, 2)) => Edge(3, 2)\n(Edge(2, 3), Edge(2, 1)) => Edge(3, 1)\n(Edge(1, 3), Edge(1, 3)) => Edge(3, 1)\n(Edge(1, 2), Edge(1, 3)) => Edge(2, 3)\n(Edge(3, 1), Edge(3, 2)) => Edge(1, 2)\n(Edge(3, 1), Edge(3, 1)) => Edge(1, 3)\n(Edge(2, 3), Edge(2, 3)) => Edge(3, 2)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(3, 2), Edge(3, 1)) => 1\n(Edge(2, 1), Edge(2, 3)) => 1\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(3, 2), Edge(3, 2)) => 2\n(Edge(1, 3), Edge(1, 2)) => 1\n(Edge(2, 3), Edge(2, 1)) => 1\n(Edge(1, 3), Edge(1, 3)) => 2\n(Edge(1, 2), Edge(1, 3)) => 1\n(Edge(3, 1), Edge(3, 2)) => 1\n(Edge(3, 1), Edge(3, 1)) => 2\n(Edge(2, 3), Edge(2, 3)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\n\n\n\n\n","category":"method"},{"location":"GKM/Connections/#GKMtools.get_any_connection-Tuple{GKM_graph}","page":"Connections","title":"GKMtools.get_any_connection","text":"get_any_connection(G::GKM_graph; store::Bool = true) -> Union{Nothing, GKM_connection}\n\nIt returns the connection of G if there exists one. Otherwise, it tries to construct one. This new connection is not guaranteed to have any special properties. In particular, it is not guaranteed to be the one induced by the geometry of a space. If it is not possible to construct it, it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"GKM/Connections/#GKMtools.build_gkm_connection","page":"Connections","title":"GKMtools.build_gkm_connection","text":"build_gkm_connection(gkm::GKM_graph, con::Dict{Tuple{Edge, Edge}, Edge}) -> GKM_connection\n\nReturn the GKM_connection object (including information of the integers a) defined by the given connection map.\n\nwarning: Warning\nThis function does not check whether the given connection map is valid (use isvalid(::GKM_connection) for that).\nThis does not save the new connection to the gkm object (use set_connection!(::GKM_graph, ::GKM_connection) for that).\n\nExample\n\njulia> G = projective_space(GKM_graph, 1)\nGKM graph with 2 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1)\n\njulia> con = Dict{Tuple{Edge, Edge}, Edge}()\nDict{Tuple{Edge, Edge}, Edge}()\n\njulia> con[(Edge(1, 2), Edge(1, 2))] = Edge(2, 1)\nEdge(2, 1)\n\njulia> con[(Edge(2, 1), Edge(2, 1))] = Edge(1, 2)\nEdge(1, 2)\n\njulia> C = build_gkm_connection(G, con)\nConnection:\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\nnote: Note\nIn this example, it is unnecessary to define the connection manually, since there is a unique one. To get it, simply use get_connection(G).\n\n\n\n\n\nbuild_gkm_connection(gkm::GKM_graph, a::Dict{Tuple{Edge, Edge}, ZZRingElem}) -> GKM_connection\n\nReturn the GKM_connection object (including the connection map nabla) defined by the given integers a.\n\nwarning: Warning\nThis function does not check whether the given connection map is valid (use isvalid(::GKM_connection) for that).\nThis does not save the new connection to the gkm object (use set_connection!(::GKM_graph, ::GKM_connection) for that).\n\nExample\n\njulia> G = projective_space(GKM_graph, 1)\nGKM graph with 2 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1)\n\njulia> a = Dict{Tuple{Edge, Edge}, ZZRingElem}()\nDict{Tuple{Edge, Edge}, ZZRingElem}()\n\njulia> a[(Edge(1, 2), Edge(1, 2))] = 2\n2\n\njulia> a[(Edge(2, 1), Edge(2, 1))] = 2\n2\n\njulia> C = build_gkm_connection(G, a)\nConnection:\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\nnote: Note\nIn this example, it is unnecessary to define the connection manually, since there is a unique one. To get it, simply use get_connection(G).\n\n\n\n\n\n","category":"function"},{"location":"GKM/Connections/#GKMtools.set_connection!","page":"Connections","title":"GKMtools.set_connection!","text":"set_connection!(gkm::GKM_graph, con::GKM_connection)\n\nManually set the GKM connection of gkm to con. This will overwrite any previously set connection.\n\nExample\n\nAfter building the GKM_connection using build_gkm_connection like in the example above, we may assign it to the GKM graph using set_connection!:\n\njulia> G = projective_space(GKM_graph, 1);\n\njulia> a = Dict{Tuple{Edge, Edge}, ZZRingElem}();\n\njulia> a[(Edge(1, 2), Edge(1, 2))] = 2;\n\njulia> a[(Edge(2, 1), Edge(2, 1))] = 2;\n\njulia> C = build_gkm_connection(G, a);\n\njulia> set_connection!(G, C)\nConnection:\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\nnote: Note\nIn this example, it is unnecessary to set the connection manually, since there is a unique one. To get it, simply use get_connection(G).\n\n\n\n\n\n","category":"function"},{"location":"GKM/Connections/#GKMtools.isvalid_connection","page":"Connections","title":"GKMtools.isvalid_connection","text":"isvalid_connection(G::GKM_graph, con::GKM_connection; printDiagnostics::Bool=true)::Bool -> Bool\n\nReturn true if con is a valid connection of G is valid. This holds if and only if all of the followings hold:\n\ncon.con and con.a are set for all (Edge(v,w), Edge(v,u)) where (v,w) and (v,u) are edges in the graph.\ncon maps every (e,e) to reverse(e)\na maps every (e,e) to 2\nEvery pair of edges (e,ei) with same source satisfies the relation of the associated a's (see above), i.e. con.gkm.w[ei'] = con.gkm.w[ei] - con.a[(e,ei)] * con.gkm.w[e]\n\nExample\n\njulia> G = projective_space(GKM_graph, 1);\n\njulia> C = get_connection(G)\nConnection:\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\njulia> C.con[(Edge(1, 2), Edge(1, 2))] = Edge(1, 2) # Should be Edge(2, 1)!\nEdge(1, 2)\n\njulia> isvalid_connection(G, C)\nConnection doesn't map (e,e) to reverse(e) for e=Edge(1, 2).\nfalse\n\n\n\n\n\nisvalid_connection(G::GKM_graph; printDiagnostics::Bool=true)::Bool -> Bool\n\nReturn true if the connection assigned to G is valid. This holds if and only if all of the followings hold:\n\ncon.con and con.a are set for all (Edge(v,w), Edge(v,u)) where (v,w) and (v,u) are edges in the graph.\ncon maps every (e,e) to reverse(e)\na maps every (e,e) to 2\nEvery pair of edges (e,ei) with same source satisfies the relation of the associated a's (see above), i.e. con.gkm.w[ei'] = con.gkm.w[ei] - con.a[(e,ei)] * con.gkm.w[e]\n\nExample\n\njulia> G = projective_space(GKM_graph, 1);\n\njulia> C = get_connection(G)\nConnection:\n(Edge(1, 2), Edge(1, 2)) => Edge(2, 1)\n(Edge(2, 1), Edge(2, 1)) => Edge(1, 2)\na_i's:\n(Edge(1, 2), Edge(1, 2)) => 2\n(Edge(2, 1), Edge(2, 1)) => 2\n\njulia> C.con[(Edge(1, 2), Edge(1, 2))] = Edge(1, 2) # Should be Edge(2, 1)!\nEdge(1, 2)\n\njulia> isvalid_connection(G, C)\nConnection doesn't map (e,e) to reverse(e) for e=Edge(1, 2).\nfalse\n\n\n\n\n\n","category":"function"},{"location":"GKM/Connections/#GKMtools.is_compatible_with_connection","page":"Connections","title":"GKMtools.is_compatible_with_connection","text":"is_compatible_with_connection(gkmSub::GKM_subgraph, con::GKM_connection; printDiagnostics::Bool=true)::Bool\n\nReturn true if the connection map sends edge pairs contained in the subgraph to an edge of the subgraph. This is necessary for the subgraph to represent a T-invariant subspace.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Vectorbundles/#Vector-Bundles","page":"Vector Bundles","title":"Vector Bundles","text":"","category":"section"},{"location":"GKM/Vectorbundles/","page":"Vector Bundles","title":"Vector Bundles","text":"Theory of GKM vector bundles, see [GSZ12].","category":"page"},{"location":"GKM/LowdimExamples/#Low-dimensional-examples","page":"Low dimensional examples","title":"Low dimensional examples","text":"","category":"section"},{"location":"GKM/LowdimExamples/","page":"Low dimensional examples","title":"Low dimensional examples","text":"In this section we construct specific relevant GKM graphs.","category":"page"},{"location":"GKM/LowdimExamples/#Low-dimensional-GKM-graphs","page":"Low dimensional examples","title":"Low-dimensional GKM graphs","text":"","category":"section"},{"location":"GKM/LowdimExamples/#GKMtools.gkm_2d","page":"Low dimensional examples","title":"GKMtools.gkm_2d","text":"gkm_2d(w::Matrix{Int64}) -> AbstractGKM_graph\n\nReturn the 2-valent GKM cyclic connected GKM graph whose vertices are 12dotsn and whose edges are (1 2) (2 3)  (n 1). The weights of those edges are given by the rows of the matrix w.\n\nExample\n\nThe following example is the GKM graph from [GKZ24, Example 2.44, left figure], which cannot come from a Hamiltonian action. One way of seeing this is that the combinatorial Betti numbers are not the geometric Betti numbers of any connected space.\n\njulia> G = gkm_2d([1 0; 0 1; -1 0; 0 -1; 1 0; 0 1; -1 0; 0 -1;])\nGKM graph with 8 nodes, valency 2 and axial function:\n2 -> 1 => (-1, 0)\n3 -> 2 => (0, -1)\n4 -> 3 => (1, 0)\n5 -> 4 => (0, 1)\n6 -> 5 => (-1, 0)\n7 -> 6 => (0, -1)\n8 -> 1 => (0, -1)\n8 -> 7 => (1, 0)\n\njulia> betti_numbers(G)\n3-element Vector{Int64}:\n 2\n 4\n 2\n\n\n\n\n\n","category":"function"},{"location":"GKM/LowdimExamples/#GKMtools.gkm_3d_positive_non_toric","page":"Low dimensional examples","title":"GKMtools.gkm_3d_positive_non_toric","text":"gkm_3d_positive_non_toric(i::Int64) -> AbstractGKM_graph\n\nReturn the i-th GKM graph from [CK23, Appendix A]'s classification of 3-valent Hamiltonian positive GKM-graphs with 2-dimensional torus-action that are not projections of GKM graphs coming from smooth projective polytopes.\n\nThe argument i runs from 1 ot 7 and is the index in the list.\n\nExample\n\nWe reproduce here the Betti numbers and the integrals int_M (c_1(M))^3 as listed in [CK23, Appendix A].\n\njulia> for i in 1:7\n           G = gkm_3d_positive_non_toric(i)\n           integral = integrate(first_chern_class(G)^3, G)\n           println(\"Graph $i: Betti numbers = $(betti_numbers(G)), [M] . (c_1(M))^3 = $integral\")\n         end\nGraph 1: Betti numbers = [1, 1, 1, 1], [M] . (c_1(M))^3 = 54\nGraph 2: Betti numbers = [1, 2, 2, 1], [M] . (c_1(M))^3 = 30\nGraph 3: Betti numbers = [1, 2, 2, 1], [M] . (c_1(M))^3 = 40\nGraph 4: Betti numbers = [1, 2, 2, 1], [M] . (c_1(M))^3 = 46\nGraph 5: Betti numbers = [1, 2, 2, 1], [M] . (c_1(M))^3 = 48\nGraph 6: Betti numbers = [1, 3, 3, 1], [M] . (c_1(M))^3 = 26\nGraph 7: Betti numbers = [1, 3, 3, 1], [M] . (c_1(M))^3 = 38\n\n\n\n\n\n","category":"function"},{"location":"GKM/LowdimExamples/#GKMtools.gkm_3d_twisted_flag","page":"Low dimensional examples","title":"GKMtools.gkm_3d_twisted_flag","text":"gkm_3d_twisted_flag() -> AbstractGKM_graph\n\nReturn the 3-valent GKM graph of the twisted flag varieties of Eschenburg, Tolman, and Woodward (see [GKZ23, Example 4.8] and references therein).\n\nExample\n\nNote that the resulting GKM graph does not occur in the output of gkm_3d_positive_non_toric() since one edge has non-positive Chern number.\n\njulia> G = gkm_3d_twisted_flag()\nGKM graph with 6 nodes, valency 3 and axial function:\n2 -> 1 => (0, -1)\n3 -> 2 => (1, 0)\n4 -> 1 => (1, -2)\n4 -> 3 => (-1, 1)\n5 -> 2 => (1, -1)\n5 -> 4 => (0, -1)\n6 -> 1 => (1, -1)\n6 -> 3 => (2, -1)\n6 -> 5 => (1, 0)\n\njulia> print_curve_classes(G)\n2 -> 1: (0, 1), Chern number: 4\n3 -> 2: (-1, 1), Chern number: 2\n4 -> 1: (1, 0), Chern number: 2\n4 -> 3: (-2, 1), Chern number: 0\n5 -> 2: (1, 0), Chern number: 2\n5 -> 4: (-1, 1), Chern number: 2\n6 -> 1: (1, 1), Chern number: 6\n6 -> 3: (1, 0), Chern number: 2\n6 -> 5: (0, 1), Chern number: 4\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#Cohomology","page":"Cohomology","title":"Cohomology","text":"","category":"section"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"Let X be a GKM variety with respect to the complex torus T. By [GKM98], we have the following description of its equivariant cohomology ring H^*_T(XmathbbQ).","category":"page"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"Each fixed point xin X gives a ring homomorphism H^*_T(XmathbbQ)rightarrow H^*_T(xmathbbQ)cong mathbbQmathfrakt. We may combine these maps by taking all fixed points at once. Let V be the set of fixed points of X and E the set of T-invariant rational curves. That is, V are the vertices of the GKM graph and E the edges. Then the map","category":"page"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"    H^*_T(XmathbbQ) longrightarrow bigoplus_xin V mathbbQmathfrakt","category":"page"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"is injective and its image consists of all (f_x)_xin V such that f_textsrc(e)equiv f_textdst(e) mod w(e) for all edges ein E, where w(e) is the weight of e.","category":"page"},{"location":"GKM/Cohomology/","page":"Cohomology","title":"Cohomology","text":"We may further identify mathbbQmathfraktcong mathbbQt_1dotst_r where r=dim_mathbbC(T). Hence, this package represents elements of H^*_T(XmathbbQ) as tuples of polynomials indexed by vertices of the GKM graph.","category":"page"},{"location":"GKM/Cohomology/#GKMtools.is_gkm_class","page":"Cohomology","title":"GKMtools.is_gkm_class","text":"is_gkm_class(c::FreeModElem{QQMPolyRingElem}, G::GKM_graph) -> Bool\n\nReturn true if the given class represents an actual cohomology class. This holds if and only if the difference between localizations at fixed points connected through an edge e is divisible by the weight of e (see above)\n\nExamples\n\nStandard functions for accessing cohomology classes always yield GKM classes:\n\njulia> G = projective_space(GKM_graph, 1);\n\njulia> is_gkm_class(point_class(G, 1), G)\ntrue\n\nMoreover, equivariant cohomology is a ring and a module over the coefficient ring:\n\njulia> is_gkm_class(point_class(G, 1)^2 * point_class(G, 2), G)\ntrue\n\nHowever, it is possible to cook up non-GKM classes manually. In the example below, this is because w(e)=t_1-t_2, which does not divide t_1^2 - t_2. Here, e is the unique edge of the GKM graph of mathbbP^1.\n\njulia> (t1, t2) = gens(G.equivariantCohomology.coeffRing);\n\njulia> (e0, e1) = gens(G.equivariantCohomology.cohomRing);\n\njulia> c = t1^2 * e0 + t2 * e1\nt1^2*e[1] + t2*e[2]\n\njulia> is_gkm_class(c, G)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#Oscar.IntersectionTheory.point_class","page":"Cohomology","title":"Oscar.IntersectionTheory.point_class","text":"point_class(vertexLabel::String, G::GKM_graph) -> FreeModElem{QQMPolyRingElem}\n\nReturn the equivariant Poincare dual of the fixed point with given label.\n\n\n\n\n\npoint_class(vertex::Int, G::GKM_graph) -> FreeModElem{QQMPolyRingElem}\n\nReturn the equivariant Poincare dual of the given fixed point.\n\nExamples\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> point_class(1, P2)\n(t1^2 - t1*t2 - t1*t3 + t2*t3)*e[1]\n\njulia> F3 = flag_variety(GKM_graph, [1, 1, 1]);\n\njulia> point_class(1, F3)\n(t1^2*t2 - t1^2*t3 - t1*t2^2 + t1*t3^2 + t2^2*t3 - t2*t3^2)*e[1]\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.poincare_dual","page":"Cohomology","title":"GKMtools.poincare_dual","text":"poincare_dual(gkmSub::GKM_subgraph) -> FreeModElem{QQMPolyRingElem}\n\nReturn the equivariant Poincare dual cohomology class of the GKM subgraph.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> P1inP2 = gkm_subgraph_from_vertices(P2, [1, 2])\nGKM subgraph of:\nGKM graph with 3 nodes, valency 2 and axial function:\n2 -> 1 => (-1, 1, 0)\n3 -> 1 => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1, 0)\n\njulia> poincare_dual(P1inP2)\n(t1 - t3)*e[1] + (t2 - t3)*e[2]\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.weight_class","page":"Cohomology","title":"GKMtools.weight_class","text":"weight_class(e::Edge, G::GKM_graph) -> QQMPolyRingElem\n\nReturn the weight of the edge e as an element of the coefficient ring of the equivariant cohomology theory.\n\nExample\n\njulia> H7 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 7))\nGKM graph with 4 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1, 0)\n3 -> 2 => (7, 1, 0, -1)\n4 -> 1 => (0, 1, 7, -1)\n4 -> 3 => (-1, 0, 1, 0)\n\njulia> weight_class(Edge(3, 2), H7)\n7*t1 + t2 - t4\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.euler_class","page":"Cohomology","title":"GKMtools.euler_class","text":"euler_class(vertex::Int64, G::GKM_graph) -> QQMPolyRingElem\n\nReturn the Euler class of the normal bundle of the fixed point v. This is the localization of point_class(vertex, G) to the given vertex.\n\nExample\n\njulia> F3 = flag_variety(GKM_graph, [1, 1, 1]);\n\njulia> euler_class(1, F3)\nt1^2*t2 - t1^2*t3 - t1*t2^2 + t1*t3^2 + t2^2*t3 - t2*t3^2\n\njulia> point_class(1, F3)\n(t1^2*t2 - t1^2*t3 - t1*t2^2 + t1*t3^2 + t2^2*t3 - t2*t3^2)*e[1]\n\n\n\n\n\neuler_class(vertexLabel::String, G::GKM_graph) -> QQMPolyRingElem\n\nReturn the euler class of the normal bundle of the fixed point with the given label.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.integrate_gkm_class","page":"Cohomology","title":"GKMtools.integrate_gkm_class","text":"integrate_gkm_class(class::FreeModElem{QQMPolyRingElem}, G::GKM_graph; check::Bool=true) -> QQMPolyRingElem\n\nIntegrate the GKM class, yielding an element of the coefficient ring. This checks if is_gkm_class(class,R) == true and throws an error otherwise.\n\nExamples\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> integrate_gkm_class(point_class(1, P2), P2)\n1\n\njulia> P2inP1 = gkm_subgraph_from_vertices(P2, [1, 2]);\n\njulia> pd = poincare_dual(P2inP1);\n\njulia> integrate_gkm_class(pd, P2)\n0\n\njulia> integrate_gkm_class(pd^2, P2)\n1\n\njulia> (t1, t2, t3) = gens(P2.equivariantCohomology.coeffRing);\n\njulia> integrate_gkm_class(t3 * pd^2 + (t2^2 - t1)*point_class(3, P2), P2)\n-t1 + t2^2 + t3\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#Nemo.integrate","page":"Cohomology","title":"Nemo.integrate","text":"integrate(class::FreeModElem{QQMPolyRingElem}, G::GKM_graph, e::Edge) -> AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}\n\nIntegrate the cohomology class over the curve represented by the GKM graph edge. In mathematical notation, if the edge is e = (prightarrow q) and the class is c=(f_v)_vin X^T then int_e c = fracf_p - f_qw(e) where w(e) is the weight of e. If is_gkm_class(class, G) == true then the result is a polynomial in the variables gens(G.equivariantCohomology.coeffRing).\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> integrate(first_chern_class(P2), P2, Edge(1, 2))\n3\n\n\n\n\n\nintegrate(class::FreeModElem{QQMPolyRingElem}, G::GKM_graph) -> AbstractAlgebra.Generic.FracFieldElem{QQMPolyRingElem}\n\nIntegrate the cohomology class, yielding an element of the fraction field of the equivariant coefficient ring.\n\nThis uses the Atiyah–Bott localization formula:  If c = (f_v)_vin X^T then int_X c = sum_vin X^Tfracf_ve_T(T_vX) where e_T(T_vX) is the equivariant Euler class of the tangent bundle of X at the fixed point v.\n\nIf is_gkm_class(class, G) == true, this fraction will be a polynomial.\n\nnote: Note\nUse integrate_gkm_class() instead if you know that the class is a GKM class.\n\nExamples\n\njulia> G24 = flag_variety(GKM_graph, [2, 4]); # Grassmannian of 2-planes in C^4\n\njulia> integrate(point_class(G24, 1), G24)\n1\n\nIn contrast to integrate_gkm_class, we can also integrate tuples (f_v)_vin X^T that do not satisfy is_gkm_class(class) == true:\n\njulia> P1 = projective_space(GKM_graph, 1);\n\njulia> (t1, t2) = gens(P1.equivariantCohomology.coeffRing);\n\njulia> (e0, e1) = gens(P1.equivariantCohomology.cohomRing);\n\njulia> c = t1^2 * e0 + t2 * e1\nt1^2*e[1] + t2*e[2]\n\njulia> is_gkm_class(c, P1)\nfalse\n\njulia> integrate(c, P1)\n(t1^2 - t2)//(t1 - t2)\n\n\n\n\n\n","category":"function"},{"location":"GKM/Cohomology/#GKMtools.first_chern_class","page":"Cohomology","title":"GKMtools.first_chern_class","text":"first_chern_class(G::GKM_graph) -> FreeModElem{QQMPolyRingElem}\n\nReturn the equivariant first Chern class of the GKM space, i.e., c_1^T(TX) where TX is the (T-equivariant) tangent bundle of X.\n\nExamples\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> first_chern_class(P2)\n(2*t1 - t2 - t3)*e[1] + (-t1 + 2*t2 - t3)*e[2] + (-t1 - t2 + 2*t3)*e[3]\n\njulia> H3 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 3))\nGKM graph with 4 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1, 0)\n3 -> 2 => (3, 1, 0, -1)\n4 -> 1 => (0, 1, 3, -1)\n4 -> 3 => (-1, 0, 1, 0)\n\njulia> first_chern_class(H3)\n(-t1 - t2 - 2*t3 + t4)*e[1] + (-2*t1 - t2 - t3 + t4)*e[2] + (4*t1 + t2 - t3 - t4)*e[3] + (-t1 + t2 + 4*t3 - t4)*e[4]\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#Constructors","page":"Constructors","title":"Constructors","text":"","category":"section"},{"location":"GKM/Constructors/","page":"Constructors","title":"Constructors","text":"These functions allow the construction of GKM varieties.","category":"page"},{"location":"GKM/Constructors/#GKMtools.gkm_graph","page":"Constructors","title":"GKMtools.gkm_graph","text":"gkm_graph(g, labels, M, w; check=true, checkLabels=true) -> GKM_graph\n\nCreate a GKM graph from the given data.\n\nArguments\n\ng::Graph: An unoriented OSCAR graph.\nlabels::Vector{String}: A vector of strings, used to denote the vertices.\nM::AbstractAlgebra.Generic.FreeModule{R}: A OSCAR free module over mathbbZ or mathbbQ, it denotes the character group. R is either ZZRingElem or QQFieldElem.\nw::Dict{Edge, AbstractAlgebra.Generic.FreeModuleElem{R}}: The axial function. Note that it is enough to specify the weight of each edge in one orientation here. The opposite oriented edge will automatically be given minus that weight.\ncheck::Bool=true: Check if the data inserted are consistent.\ncheckLabels::Bool=true: Check that the labels don't contain the characters <, [, ], which are reserved for the output of special constructions like blowups and projective bundles.\n\nExample\n\nLet us construct the GKM graph of the projective line. First of all, we create a graph with two vertices, and one edge.\n\njulia> g = Graph{Undirected}(2)\nUndirected graph with 2 nodes and no edges\n\njulia> add_edge!(g, 1, 2);\n\nLet us define our array of labels.\n\njulia> labels = [\"a\", \"b\"];\n\nNow, we create the character group. We take a free module of rank 2 over the integers.\n\njulia> M = free_module(ZZ, 2)\nFree module of rank 2 over ZZ\n\nWe create the axial function. It is a dictionary from the set of edges to the character group. This time we have only one edge.\n\njulia> e = first(edges(g));\n\njulia> w = Dict(e => gens(M)[1] - gens(M)[2])\nDict{Edge, AbstractAlgebra.Generic.FreeModuleElem{ZZRingElem}} with 1 entry:\n  Edge(2, 1) => (1, -1)\n\nFinally, we create the GKM graph.\n\njulia> gkm_graph(g, labels, M, w)\nGKM graph with 2 nodes, valency 1 and axial function:\nb -> a => (1, -1)\n\nwarning: Warning\nDo not change the number of verices after this.\nDon't modify the underlying OSCAR graph directly after this. Use the functions of this package instead.\nAll edges should be added immediately after calling this function and not changed afterwards.\n\nnote: Note\nAfter you have added all edges using add_edge!, you may use initialize! to calculate the GKM connection (if it is unique) and the curve classes. If you don't do this, those data will be calculated whenever required for the first time.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#GKMtools.empty_gkm_graph","page":"Constructors","title":"GKMtools.empty_gkm_graph","text":"empty_gkm_graph(n::Int64, r::Int64, labels::Vector{String}) -> GKM_graph\n\nReturn the GKM graph with n fixed points, no edges, torus rank r and vertices labelled by labels.\n\nExample\n\njulia> G = empty_gkm_graph(2, 2, [\"a\", \"b\"])\nGKM graph with 2 nodes, valency 0 and axial function:\n\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#GKMtools.initialize!","page":"Constructors","title":"GKMtools.initialize!","text":"initialize!(gkm::GKM_graph; connection::Bool=true, curveClasses::Bool=true)\n\nYou may optionally call this function as soon as all edges have been added to the GKM graph to calculate the GKM connection (if unique) and the curve classes of the gkm graph. This will set the fields gkm.connection and gkm.H2 that are initially nothing. If you don't call this, these fields will be initialized later if possible, which might take some time at unexpected moments (especially for curve classes). If any of those fields are already set, this will not overwrite them.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#GKMtools.convert_weights","page":"Constructors","title":"GKMtools.convert_weights","text":"convert_weights(G::GKM_graph) -> GKM_graph{QQFieldElem}\n\nIt returns G, but the character group will be embedded into a free mathbbQ-module.\n\nExamples\n\njulia> G_over_Z = generalized_gkm_flag(root_system(:A, 1))\nGKM graph with 2 nodes, valency 1 and axial function:\ns1 -> id => (-1, 1)\n\njulia> typeof(G_over_Z)\nGKM_graph{ZZRingElem}\n\njulia> G_over_Q = convert_weights(G_over_Z)\nGKM graph with 2 nodes, valency 1 and axial function:\ns1 -> id => (-1, 1)\n\njulia> typeof(G_over_Q)\nGKM_graph{QQFieldElem}\n\n\n\n\n\n","category":"function"},{"location":"GKM/Constructors/#Base.isvalid-Tuple{GKM_graph}","page":"Constructors","title":"Base.isvalid","text":"isvalid(gkm::GKM_graph; printDiagnostics::Bool=true) -> Bool\n\nReturn true if the GKM graph is valid. This means:\n\nEvery vertex has the same degree\nThe weights are defined for every edge and every reverse of every edge\nThe weights belong to the weight lattice\nThe weights of an edge and its reverse sum to zero\nThere are the right number of vertex labels\nIf the valency is at least two, the weights of the graph are 2-independent.\nVertex labels must be unique\nThe equivariant cohomology ring has rank = number of vertices of graph\nThe coefficient ring of the equivariant cohomology ring has number of generators = torus rank.\n\nExamples\n\nThe standard constructions always produce valid GKM graphs, e.g. the complex projective space mathbbP^3:\n\njulia> isvalid(projective_space(GKM_graph, 3))\ntrue\n\nOn the other hand, here is an example showing why one should never modify the underlying OSCAR graph of a GKM graph directly:\n\njulia> G = empty_gkm_graph(3, 1, [\"v1\", \"v2\", \"v3\"])\nGKM graph with 3 nodes, valency 0 and axial function:\n\njulia> add_edge!(G.g, 1, 2)\ntrue\n\njulia> isvalid(G)\nThe valency is not the same for all vertices\nfalse\n\njulia> add_edge!(G.g, 1, 3)\ntrue\n\njulia> add_edge!(G.g, 2, 3)\ntrue\n\njulia> isvalid(G)\nWeight of Edge(2, 1) is missing.\nfalse\n\nInstead, one should add all edges with add_edge!(G, \"v1\", \"v2\", weight) (see above).\n\n\n\n\n\n","category":"method"},{"location":"GKM/CurveClasses/#Curve-Classes","page":"Curve Classes","title":"Curve Classes","text":"","category":"section"},{"location":"GKM/CurveClasses/","page":"Curve Classes","title":"Curve Classes","text":"Given a GKM variety X, every edge e of its GKM graph corresponds to a T-invariant rational curve C_e in X, and hence to a second homology class C_ein H_2(XmathbbZ). As we discuss in the supporting paper, it turns out that:","category":"page"},{"location":"GKM/CurveClasses/","page":"Curve Classes","title":"Curve Classes","text":"The subgroup of H_2(XmathbbZ) generated by C_e  e text an edge of the GKM graph coincides with the subgroup generated  by algebraic cycles.\nThe weights of the GKM graph give rise to an explicit presentation of this subgroup in terms of a complete set of relations between the C_e classes.","category":"page"},{"location":"GKM/CurveClasses/","page":"Curve Classes","title":"Curve Classes","text":"This is the basis on which this package handles curve classes of GKM spaces.","category":"page"},{"location":"GKM/CurveClasses/#GKMtools.print_curve_classes","page":"Curve Classes","title":"GKMtools.print_curve_classes","text":"print_curve_classes(G::GKM_graph)\n\nFor each edge, print the representative of its curve class and its Chern numner.\n\nExamples\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> print_curve_classes(P2)\n2 -> 1: (1), Chern number: 3\n3 -> 1: (1), Chern number: 3\n3 -> 2: (1), Chern number: 3\n\njulia> H5 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 5));\n\njulia> print_curve_classes(H5)\n2 -> 1: (-5, 1), Chern number: -3\n3 -> 2: (1, 0), Chern number: 2\n4 -> 1: (1, 0), Chern number: 2\n4 -> 3: (0, 1), Chern number: 7\n\njulia> P2_blown_up = blow_up_ex_div(gkm_subgraph_from_vertices(P2, [1]))\nGKM subgraph of:\nGKM graph with 4 nodes, valency 2 and axial function:\n[1>3] -> [1>2] => (0, -1, 1)\n2 -> [1>2] => (-1, 1, 0)\n3 -> [1>3] => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n[1>3] -> [1>2] => (0, -1, 1)\n\njulia> print_curve_classes(P2_blown_up.Codomain)\n[1>3] -> [1>2]: (-1, 1), Chern number: 1\n2 -> [1>2]: (1, 0), Chern number: 2\n3 -> [1>3]: (1, 0), Chern number: 2\n3 -> 2: (0, 1), Chern number: 3\n\n\n\n\n\n","category":"function"},{"location":"GKM/CurveClasses/#GKMtools.curve_class","page":"Curve Classes","title":"GKMtools.curve_class","text":"curve_class(G::GKM_graph, src::String, dst::String)\n\nReturn the second homology class represented by the given edge whose source and destination have the given labels.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> P2_blown_up = blow_up_ex_div(gkm_subgraph_from_vertices(P2, [1]))\nGKM subgraph of:\nGKM graph with 4 nodes, valency 2 and axial function:\n[1>3] -> [1>2] => (0, -1, 1)\n2 -> [1>2] => (-1, 1, 0)\n3 -> [1>3] => (-1, 0, 1)\n3 -> 2 => (0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n[1>3] -> [1>2] => (0, -1, 1)\n\njulia> curve_class(P2_blown_up.Codomain, \"[1>3]\", \"[1>2]\")\n(-1, 1)\n\n\n\n\n\ncurve_class(G::GKM_graph, e::Edge)\n\nReturn the second homology class represented by the given edge.\n\n\n\n\n\n","category":"function"},{"location":"GKM/CurveClasses/#Oscar.IntersectionTheory.chern_number","page":"Curve Classes","title":"Oscar.IntersectionTheory.chern_number","text":"chern_number(e::Edge, G::GKM_graph) -> ZZRingElem\n\nReturn the Chern number of the curve class represented by the given edge. This is the pairing of the curve class with the first Chern class of the tangent bundle.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> chern_number(Edge(1, 2), P2)\n3\n\njulia> partialFlagVariety = flag_variety(GKM_graph, [1, 2, 3, 1]);\n\njulia> chern_number(Edge(1, 2), partialFlagVariety)\n4\n\n\n\n\n\nchern_number(G::GKM_graph, beta::CurveClass; check::Bool=true)::ZZRingElem\n\nReturn the Chern number of the curve class beta. This is the pairing of the second homology class with the first Chern class of the tangent bundle.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> chern_number(P2, 2 * curve_class(P2, Edge(1, 2)))\n6\njulia> chern_number(P2, -2 * curve_class(P2, Edge(1, 2)) + curve_class(P2, Edge(2, 3)))\n-3\n\n\n\n\n\n","category":"function"},{"location":"GKM/CurveClasses/#Hecke.is_effective","page":"Curve Classes","title":"Hecke.is_effective","text":"is_effective(G::GKM_graph, beta::CurveClass) -> Bool\n\nReturn whether beta is in the effective cone, i.e. whether it is a non-negative linear combination of edge curve classes.\n\nnote: Note\nWe consider the effective cone to be closed and hence zero is also considered effective.\n\nExamples\n\njulia> F3 = flag_variety(GKM_graph, [1, 1, 1]);\n\njulia> beta = curve_class(F3, Edge(1, 2));\n\njulia> is_effective(F3, beta)\ntrue\n\njulia> is_effective(F3, 0*beta)\ntrue\n\njulia> is_effective(F3, -1*beta)\nfalse\n\njulia> is_effective(F3, 2*beta)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"GKM/CurveClasses/#GKMtools.GKM_second_homology","page":"Curve Classes","title":"GKMtools.GKM_second_homology","text":"GKM_second_homology(G::GKM_graph) -> GKM_H2\n\nIt builds (if necessary) and returns the GKM_H2 object of this GKM graph. The result is stored in G for future use.  Assume that G represents a GKM variety X. The returned GKM_H2 struct is by definition the quotient of the mathbbZ-module generated by the GKM graph's edges modulo the relations in H_2(XmathbbZ). Thus, it is the submodule of H_2(XmathbbZ) generated by classes of T-invariant curves.\n\nnote: Note\nIf G.H2 is already set, it just returns that. Otherwise it calculates it afresh and stores it there.\nFor most applications, it is not necessary to work with this object directly. Use functions like curve_class and chern_number instead.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Seidelspace/#Seidel-Space","page":"Seidel Space","title":"Seidel Space","text":"","category":"section"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"We follow [Iri17, Definition 3.2] in our description of the Seidel space. Let X be a (smooth) GKM variety with torus action by T. Let iotacolonmathbbC^timesrightarrow T be a group homomorphism.","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"The Seidel space S_X associated to this datum is a X-bundle over mathbbP^1 which is trivialized over","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"  beginalign*\n    U_0 = 1u  uinmathbbCsubsetmathbbP^1\n    U_infty = v1  vinmathbbCsubsetmathbbP^1\n  endalign*","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"The transition function on U_0cap U_infty is given by","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"  U_0times X ni (1u x) longmapsto (u^-11 iota(u)cdot x) in U_inftytimes X","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"Globally, it can be described as","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"  S_X = left( mathbbC^2setminus0times X right)  mathbbC^times","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"where lambdainmathbbC^times acts by lambdacdot ((v u) x) = ((lambda v lambda u) iota(lambda)cdot x).","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"Let widehatT= TtimesmathbbC^times. Then widehatT acts on S_X by (t s)cdot ((v su) tcdot x).","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"That is, widehatT acts on S_XrightarrowmathbbP^1 via the T-action on the fibres X and via the standard mathbbC^times-action on the base mathbbP^1.","category":"page"},{"location":"GKM/Seidelspace/","page":"Seidel Space","title":"Seidel Space","text":"note: Note\nIf X is a GKM space with respect to T, then S_X is a GKM space with respect to widehatT, which is implemented in this package.\nThe GKM graph and connection of S_X is described in the supporting paper.","category":"page"},{"location":"GKM/Seidelspace/#GKMtools.Seidel_space","page":"Seidel Space","title":"GKMtools.Seidel_space","text":"Seidel_space(G::GKM_graph, w::AbstractAlgebra.Generic.FreeModuleElem{R}; basePoint::Int64 = 1) -> GKM_graph\n\nConstruct the Seidel space associated to the GKM graph G (representing the GKM variety X) and the map iotamathbbC^timesrightarrow T given by the element winmathfrakt.\n\nOptional arguments:\n\nbasePoint::Int64: This is the vertex of G so that in the internal presentation of the curve classes of S_X, the curve class of the section of S_Xrightarrow mathbbP^1  associated to the vertex basePoint is represented by (0,...,0,1).  The first entries correspond to curve classes of X. The last is the degree of the curve class projected to mathbbP^1.\n\nExamples\n\njulia> G = projective_space(GKM_graph, 2);\n\njulia> S = Seidel_space(G, gens(G.M)[1])\nGKM graph with 6 nodes, valency 3 and axial function:\n[2]_0 -> [1]_0 => (-1, 1, 0, 0)\n[3]_0 -> [1]_0 => (-1, 0, 1, 0)\n[3]_0 -> [2]_0 => (0, -1, 1, 0)\n[1]_inf -> [1]_0 => (0, 0, 0, -1)\n[2]_inf -> [2]_0 => (0, 0, 0, -1)\n[2]_inf -> [1]_inf => (-1, 1, 0, 1)\n[3]_inf -> [3]_0 => (0, 0, 0, -1)\n[3]_inf -> [1]_inf => (-1, 0, 1, 1)\n[3]_inf -> [2]_inf => (0, -1, 1, 0)\n\njulia> S = Seidel_space(G, gens(G.M)[1] + 7*gens(G.M)[2])\nGKM graph with 6 nodes, valency 3 and axial function:\n[2]_0 -> [1]_0 => (-1, 1, 0, 0)\n[3]_0 -> [1]_0 => (-1, 0, 1, 0)\n[3]_0 -> [2]_0 => (0, -1, 1, 0)\n[1]_inf -> [1]_0 => (0, 0, 0, -1)\n[2]_inf -> [2]_0 => (0, 0, 0, -1)\n[2]_inf -> [1]_inf => (-1, 1, 0, -6)\n[3]_inf -> [3]_0 => (0, 0, 0, -1)\n[3]_inf -> [1]_inf => (-1, 0, 1, 1)\n[3]_inf -> [2]_inf => (0, -1, 1, 7)\n\njulia> print_curve_classes(S)\n[2]_0 -> [1]_0: (1, 0), Chern number: 3\n[3]_0 -> [1]_0: (1, 0), Chern number: 3\n[3]_0 -> [2]_0: (1, 0), Chern number: 3\n[1]_inf -> [1]_0: (0, 1), Chern number: -3\n[2]_inf -> [2]_0: (6, 1), Chern number: 15\n[2]_inf -> [1]_inf: (1, 0), Chern number: 3\n[3]_inf -> [3]_0: (-1, 1), Chern number: -6\n[3]_inf -> [1]_inf: (1, 0), Chern number: 3\n[3]_inf -> [2]_inf: (1, 0), Chern number: 3\n\n\nUsing a different base point does not change the resulting GKM graph but gives a different internal presentation of the curve classes.\n\njulia> S = Seidel_space(G, gens(G.M)[1] + 7*gens(G.M)[2]; basePoint=2)\nGKM graph with 6 nodes, valency 3 and axial function:\n[2]_0 -> [1]_0 => (-1, 1, 0, 0)\n[3]_0 -> [1]_0 => (-1, 0, 1, 0)\n[3]_0 -> [2]_0 => (0, -1, 1, 0)\n[1]_inf -> [1]_0 => (0, 0, 0, -1)\n[2]_inf -> [2]_0 => (0, 0, 0, -1)\n[2]_inf -> [1]_inf => (-1, 1, 0, -6)\n[3]_inf -> [3]_0 => (0, 0, 0, -1)\n[3]_inf -> [1]_inf => (-1, 0, 1, 1)\n[3]_inf -> [2]_inf => (0, -1, 1, 7)\n\njulia> print_curve_classes(S)\n[2]_0 -> [1]_0: (1, 0), Chern number: 3\n[3]_0 -> [1]_0: (1, 0), Chern number: 3\n[3]_0 -> [2]_0: (1, 0), Chern number: 3\n[1]_inf -> [1]_0: (-6, 1), Chern number: -3\n[2]_inf -> [2]_0: (0, 1), Chern number: 15\n[2]_inf -> [1]_inf: (1, 0), Chern number: 3\n[3]_inf -> [3]_0: (-7, 1), Chern number: -6\n[3]_inf -> [1]_inf: (1, 0), Chern number: 3\n[3]_inf -> [2]_inf: (1, 0), Chern number: 3\n\n\n\n\n\n","category":"function"},{"location":"GKM/GKM/#Generalities-on-GKM-graphs","page":"GKM Graphs","title":"Generalities on GKM graphs","text":"","category":"section"},{"location":"GKM/GKM/#Definition","page":"GKM Graphs","title":"Definition","text":"","category":"section"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"GKM spaces have been introduced in [GKM98]. Many of the combinatorial definitions in this package follow [GZ00]. For the purpose of this package, by GKM variety we mean a smooth projective varieties over mathbbC with an algebraic torus action such that the action has a finite number of fixed points and a finite number of 1-dimensional orbits.","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"The GKM graph associated to a torus T acting on a GKM variety X is the following datum:","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"A graph having the fixed points as vertices, such that two vertices are connected by an unoriented) edge if there is a 1-dimensional orbit passing through the two fixed points.\nAn axial function mathrmwcolon E rightarrow M from the set of oriented edges of the graph to the weight lattice M of T. (By oriented edge we mean an unoriented edge of the graph plus a choice of orientation.)","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"In this package, the codomain M of the axial function can be a free mathbbZ-module or a free mathbbQ-module. Since the GKM graph of a GKM variety is always regular (with the valency of every vertex being the complex dimension of the space), this package assumes that GKM graphs are regular.","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"Famous examples of GKM varities include projective space, (generalised/partial) flag varieties, smooth Schubert varieties, and smooth toric varieties, see Standard Constructions.","category":"page"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"This package represents GKM varieties purely by their GKM graphs. For some applications, the additional datum of a GKM connection is necessary, see Connections.","category":"page"},{"location":"GKM/GKM/#Index","page":"GKM Graphs","title":"Index","text":"","category":"section"},{"location":"GKM/GKM/","page":"GKM Graphs","title":"GKM Graphs","text":"","category":"page"},{"location":"GKM/Properties/#Properties-of-GKM-graphs","page":"Properties","title":"Properties of GKM graphs","text":"","category":"section"},{"location":"GKM/Properties/","page":"Properties","title":"Properties","text":"These are the main properties of GKM graphs.","category":"page"},{"location":"GKM/Properties/#Oscar.betti_numbers","page":"Properties","title":"Oscar.betti_numbers","text":"betti_numbers(G::GKM_graph) -> Vector{Int64}\n\nReturn the array betti_numbers such that betti_numbers[i+1] is the 2i-th combinatorial Betti number for i from 0 to the valency of G, as defined in [GZ01, section 1.3].\n\nnote: Note\ni ranges from 0 to the valency of G, that can be obtained by valency(G).\nFrom [GZ01, Theorem 1.3.2], the combinatorial Betti numbers equal the Betti numbers of the underlying GKM space if the torus action is Hamiltonian. This holds automatically for smooth projective varieties with algebraic torus action (cf. [MFK94, Example 8.1 (ii)]).\n\nwarning: Warning\nbetti_numbers[1] is the 0-th Betti number, since Julia arrays are 1-based and not 0-based.\n\nExamples\n\njulia> H6 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 6));\n\njulia> betti_numbers(H6)\n3-element Vector{Int64}:\n 1\n 2\n 1\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.valency","page":"Properties","title":"GKMtools.valency","text":"valency(G::GKM_graph) -> Int64\n\nReturn the valency of G, i.e. the degree of each vertex.\n\nExample:\n\nThe valency of the GKM graph of mathbbP^3 is 3, since all of the fixed points 1000 dots 0001 are connected to each other via some T-invariant mathbbP^1's. For example, 1000 and 0100 are connected by xy00  xyinmathbbC.\n\njulia> valency(projective_space(GKM_graph, 3))\n3\njulia> valency(grassmannian(GKM_graph, 2, 4)) # The Grassmannian of 2-planes in C^4\n4\njulia> valency(flag_variety(GKM_graph, [1, 1, 1, 1])) # The variety of full flags in C^4\n6\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.rank_torus","page":"Properties","title":"GKMtools.rank_torus","text":"rank_torus(G::GKM_graph) -> Int64\n\nReturn the rank of the torus acting on G. That is, the rank of the character group.\n\nExamples\n\nBy default, the torus acting on mathbbP^n is (mathbbC^times)^n+1, acting by rescaling the homogeneous coordinates.\n\njulia> P3 = projective_space(GKM_graph, 3);\n\njulia> rank_torus(P3)\n4\n\nTaking products adds the rank:\n\njulia> H6 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 6));\n\njulia> rank_torus(H6)\n4\njulia> rank_torus(H6 * P3)\n8\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.is2_indep","page":"Properties","title":"GKMtools.is2_indep","text":"is2_indep(G::GKM_graph) -> Bool\n\nReturn true if G is 2-independent, i.e. the weights of every two edges at a vertex are linearly independent.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.is3_indep","page":"Properties","title":"GKMtools.is3_indep","text":"is3_indep(G::GKM_graph) -> Bool\n\nReturn true if G is 3-independent, i.e. the weights of every three edges at a vertex are linearly independent.\n\nExample\n\nThe weights of mathbbP^3 at the fixed point 1000 are t_i-t_0iin1 2 3, which are linearly independent over mathbbC.\n\njulia> is3_indep(projective_space(GKM_graph, 3))\ntrue\n\nThe variety of complete flags in mathbbC^3 is an example of a GKM graph that is not 3-independent:\n\njulia> G = flag_variety(GKM_graph, [1, 1, 1])\nGKM graph with 6 nodes, valency 3 and axial function:\n13 -> 12 => (0, -1, 1)\n21 -> 12 => (-1, 1, 0)\n23 -> 13 => (-1, 1, 0)\n23 -> 21 => (-1, 0, 1)\n31 -> 13 => (-1, 0, 1)\n31 -> 21 => (0, -1, 1)\n32 -> 12 => (-1, 0, 1)\n32 -> 23 => (0, -1, 1)\n32 -> 31 => (-1, 1, 0)\n\njulia> is3_indep(G)\nfalse\n\nwarning: Warning\nThis function throws an error if the valency of G is less than 3, since in this case it is not possible to pick three different edges ta a vertex.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Properties/#GKMtools.is_strictly_nef","page":"Properties","title":"GKMtools.is_strictly_nef","text":"is_strictly_nef(G::GKM_graph) -> Bool\n\nIt returns true if and only if the Chern numbers of all curve classes corresponding to edges of the GKM graph are strictly positive.\n\nExamples\n\njulia> F3 = flag_variety(GKM_graph, [1,1,1]);\n\njulia> print_curve_classes(F3)\n13 -> 12: (0, 1), Chern number: 2\n21 -> 12: (1, 0), Chern number: 2\n23 -> 13: (1, 1), Chern number: 4\n23 -> 21: (0, 1), Chern number: 2\n31 -> 13: (1, 0), Chern number: 2\n31 -> 21: (1, 1), Chern number: 4\n32 -> 12: (1, 1), Chern number: 4\n32 -> 23: (1, 0), Chern number: 2\n32 -> 31: (0, 1), Chern number: 2\n\njulia> is_strictly_nef(F3)\ntrue\n\njulia> H5 = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 5))\nGKM graph with 4 nodes, valency 2 and axial function:\n2 -> 1 => (1, 0, -1, 0)\n3 -> 2 => (5, 1, 0, -1)\n4 -> 1 => (0, 1, 5, -1)\n4 -> 3 => (-1, 0, 1, 0)\n\njulia> print_curve_classes(H5)\n2 -> 1: (-5, 1), Chern number: -3\n3 -> 2: (1, 0), Chern number: 2\n4 -> 1: (1, 0), Chern number: 2\n4 -> 3: (0, 1), Chern number: 7\n\njulia> is_strictly_nef(H5)\nfalse\n\n\n\n\n\n","category":"function"},{"location":"GKM/Operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"GKM/Operators/#GKM-Subgraphs","page":"Operators","title":"GKM Subgraphs","text":"","category":"section"},{"location":"GKM/Operators/#GKMtools.gkm_subgraph_from_vertices","page":"Operators","title":"GKMtools.gkm_subgraph_from_vertices","text":"gkm_subgraph_from_vertices(gkm::GKM_graph, vertices::Vector{Int64}) -> GKM_subgraph\n\nReturn the GKM subgraph induced by the given vertices.\n\nnote: Note\nThis does not check if the result is a valid GKM graph (use may use isvalid for that).\nIf possible, the subgraph will be endowed with the connection induced from the supergraph.\n\nExample\n\njulia> G = projective_space(GKM_graph, 3)\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\n\njulia> S = gkm_subgraph_from_vertices(G, [2, 3])\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n3 -> 2 => (0, -1, 1, 0)\n\njulia> S.Domain\nGKM graph with 2 nodes, valency 1 and axial function:\n3 -> 2 => (0, -1, 1, 0)\n\njulia> S.Codomain\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\n\n\n\n\n\n\ngkm_subgraph_from_vertices(gkm::GKM_graph, vertexLabels::Vector{String}) -> GKM_subgraph\n\nAs before, but the vertices are given by their labels.\n\n\n\n\n\n","category":"function"},{"location":"GKM/Operators/#GKMtools.gkm_subgraph_from_edges","page":"Operators","title":"GKMtools.gkm_subgraph_from_edges","text":"gkm_subgraph_from_edges(gkm::GKM_graph, edges::Vector{Edge}) -> GKM_subgraph\n\nReturn the GKM subgraph induced by the given edges.\n\nnote: Note\nThis does not check if the result is a valid GKM graph (use isvalid for that).\nIf possible, the subgraph will be endowed with the connection induced from the supergraph.\n\nExample\n\njulia> G = projective_space(GKM_graph, 3);\n\njulia> S = gkm_subgraph_from_edges(G, [Edge(1, 2), Edge(2, 3)])\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 3 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 2 => (0, -1, 1, 0)\n\n\n\n\n\n","category":"function"},{"location":"GKM/Operators/#Base.isvalid-Tuple{GKMtools.GKM_subgraph}","page":"Operators","title":"Base.isvalid","text":"isvalid(gkmsub::GKM_subgraph; printDiagnostics::Bool = true) -> Bool\n\nReturn true if the given GKM subgraph is valid. This holds if and only if all of the following hold:\n\nThe supergraph and subgraph are both valid GKM GKMsubgraphs of the same character group\nThe subgraph is mathematically a subgraph of the supergraph\nThe edge weights of the subgraph match that of the supergraph\nThe vertex labels of the subgraph and the supergraph match.\n\nwarning: Warning\nIf a connection for the supergraph is set, this does not check if it is compatible with the subgraph. Use is_compatible_with_connection() for this.\n\n\n\n\n\n","category":"method"},{"location":"GKM/Operators/#Blowups","page":"Operators","title":"Blowups","text":"","category":"section"},{"location":"GKM/Operators/#GKMtools.blow_up_ex_div","page":"Operators","title":"GKMtools.blow_up_ex_div","text":"blow_up_ex_div(gkmSub::GKM_subgraph) -> GKM_subgraph\n\nIt computes the GKM graph of the blow up of the GKM subgraph gkmSub. It returns the GKM subgraph of exceptional divisor inside the blow up.\n\nnote: Note\nThe GKM graph needs to have the connection field set. The returned blowup graph and subgraph will also have the connection field set, but not the curveClasses field.  (It will be calculated automatically on demand via GKM_second_homology).  Mathematically, this follows [GZ01, section 2.2.1].\n\nwarning: Warning\nThis will build an undirected graph. Behaviour with directed graphs as input is not tested.\n\nExamples\n\njulia> G = projective_space(GKM_graph, 3) # 3-dimensional projective space\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\n\njulia> S = gkm_subgraph_from_vertices(G, [1, 2]) # we take the subgraph of two vertices, it corresponds to a line\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 2 nodes, valency 1 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n\njulia> blowupSub = blow_up_ex_div(S) # blowup of P3 along the line S\nGKM subgraph of:\nGKM graph with 6 nodes, valency 3 and axial function:\n[1>4] -> [1>3] => (0, 0, -1, 1)\n[2>3] -> [1>3] => (-1, 1, 0, 0)\n[2>4] -> [1>4] => (-1, 1, 0, 0)\n[2>4] -> [2>3] => (0, 0, -1, 1)\n3 -> [1>3] => (-1, 0, 1, 0)\n3 -> [2>3] => (0, -1, 1, 0)\n4 -> [1>4] => (-1, 0, 0, 1)\n4 -> [2>4] => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 4 nodes, valency 2 and axial function:\n[1>4] -> [1>3] => (0, 0, -1, 1)\n[2>3] -> [1>3] => (-1, 1, 0, 0)\n[2>4] -> [1>4] => (-1, 1, 0, 0)\n[2>4] -> [2>3] => (0, 0, -1, 1)\n\njulia> Spoint = gkm_subgraph_from_vertices(G, [1]) # we take the subgraph of one vertex that is an invariant point\nGKM subgraph of:\nGKM graph with 4 nodes, valency 3 and axial function:\n2 -> 1 => (-1, 1, 0, 0)\n3 -> 1 => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> 1 => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 1 nodes, valency 0 and axial function:\n\njulia> blowupPt = blow_up_ex_div(Spoint) # blowup of P3 at a point\nGKM subgraph of:\nGKM graph with 6 nodes, valency 3 and axial function:\n[1>3] -> [1>2] => (0, -1, 1, 0)\n[1>4] -> [1>2] => (0, -1, 0, 1)\n[1>4] -> [1>3] => (0, 0, -1, 1)\n2 -> [1>2] => (-1, 1, 0, 0)\n3 -> [1>3] => (-1, 0, 1, 0)\n3 -> 2 => (0, -1, 1, 0)\n4 -> [1>4] => (-1, 0, 0, 1)\n4 -> 2 => (0, -1, 0, 1)\n4 -> 3 => (0, 0, -1, 1)\nSubgraph:\nGKM graph with 3 nodes, valency 2 and axial function:\n[1>3] -> [1>2] => (0, -1, 1, 0)\n[1>4] -> [1>2] => (0, -1, 0, 1)\n[1>4] -> [1>3] => (0, 0, -1, 1)\n\n\n\n\n\n","category":"function"},{"location":"GKM/Operators/#Products","page":"Operators","title":"Products","text":"","category":"section"},{"location":"GKM/Operators/#Base.:*-Tuple{GKM_graph, GKM_graph}","page":"Operators","title":"Base.:*","text":"*(G1::GKM_graph, G2::GKM_graph; calculateCurveClasses::Bool=true, calculateConnection::Bool=true) -> GKM_graph\n\nIt constructs the product of two GKM graphs.\n\nExamples\n\njulia> G = generalized_gkm_flag(root_system(:A, 1))\nGKM graph with 2 nodes, valency 1 and axial function:\ns1 -> id => (-1, 1)\n\njulia> G*G\nGKM graph with 4 nodes, valency 2 and axial function:\ns1,id -> id,id => (-1, 1, 0, 0)\nid,s1 -> id,id => (0, 0, -1, 1)\ns1,s1 -> s1,id => (0, 0, -1, 1)\ns1,s1 -> id,s1 => (-1, 1, 0, 0)\n\n\nnote: Note\nThe character group is of type free mathbbQ-module if this holds for one of the two GKM graphs.\n\n\n\n\n\n","category":"method"},{"location":"GW/GW/#Equivariant-Gromov–Witten-invariants-of-GKM-graphs","page":"Gromov–Witten invariants","title":"Equivariant Gromov–Witten invariants of GKM graphs","text":"","category":"section"},{"location":"GW/GW/","page":"Gromov–Witten invariants","title":"Gromov–Witten invariants","text":"One of the main features of this package is to calculate equivariant Gromov-Witten invariants of GKM varieties X.","category":"page"},{"location":"GW/GW/","page":"Gromov–Witten invariants","title":"Gromov–Witten invariants","text":"Mathematical ingredients: The following mathematical ingredients are used in the package:","category":"page"},{"location":"GW/GW/","page":"Gromov–Witten invariants","title":"Gromov–Witten invariants","text":"The localization formula from [LS17] that expresses equivariant Gromov-Witten invariants in the form\n  GW^T_Xg=0mbeta() = sum_overrightarrowGamma GW^T_overrightarrowGamma\nwhere the sum is over certain decorated trees overrightarrowGamma mapping into the GKM graph of X, such that the edge multiplicities sum to the curve class betain H_2(XmathbbZ). Here, GW^T_overrightarrowGamma is a rational function in dimT many variables, i.e. an element of textFracH_T^*(textptmathbbQ).\nAn efficient way of enumerating trees with marked points and counting their automorphisms (inspired by [WROM86]).\nA way of enumerating all combination of edges with multiplicities in the GKM graph that sum to a given curve class betain H_2(XmathbbZ) (see supporting paper).","category":"page"},{"location":"GW/GW/#Integrating-on-the-moduli-space","page":"Gromov–Witten invariants","title":"Integrating on the moduli space","text":"","category":"section"},{"location":"GW/GW/#GKMtools.gromov_witten","page":"Gromov–Witten invariants","title":"GKMtools.gromov_witten","text":"gromov_witten(G::GKM_graph, beta::CurveClass, n_marks::Int64, P_input::EquivariantClass; show_bar::Bool = false) -> GW invariants\n\nIntegrate the class P_input over the moduli space overlinemathcalM_0n(Xbeta) of genus 0 stable maps to X in class betain H_2(XmathbbZ) with n_marks marked points. The result is an element of textFrac(H_T^*(textptmathbbQ)), i.e. a rational function in dim_mathbbC(T) many variables.\n\nnote: Note\nIf the underlying space is a (smooth projective) GKM variety then the output should in fact live in H_T^*(textptmathbbQ), so it should be  a polynomial in the dim_mathbbC(T) many variables.\n\nwarning: Warning\nThe GKM graph G must have a connection, as this datum is required by the localization formula [LS17].\n\nArguments\n\nG::GKM_graph: The GKM graph of the target GKM variety X.\nbeta::CurveClass: The (non-zero) curve class betain H_2(XmathbbZ) in which the image of the stable map should lie.  To produce beta, use functions like curve_class (see Curve Classes).\nP_input::EquivariantClass: The equivariant cohomology class on overlinemathcalM_0n(Xbeta) that is being integrated.  Use the functions ev, class_one, and Psi to produce this. These classes also support arithmetic using +, *, et cetera.\nshow_bar::Bool: If true, a progress bar will be displayed showing the estimated time until completion. This should be used for big examples.\nfast_mode::Bool: If the expected result of the computation is a number, this option will speed up the computation.\n\nwarning: Warning\nIf the expected result of the computation is not a number and fast_mode is true, the result will be a meaningless number.\n\nExample\n\njulia> P2 = projective_space(GKM_graph, 2);\n\njulia> beta = curve_class(P2, Edge(1, 2));\n\njulia> gromov_witten(P2, beta, 1, ev(1, point_class(P2, 1)); show_bar=false)\n0\n\njulia> gromov_witten(P2, beta, 2, ev(1, point_class(P2, 1)) * ev(2, point_class(P2, 2)); show_bar=false)\n1\n\njulia> gromov_witten(P2, beta, 2, ev(1, point_class(P2, 1)) * ev(2, point_class(P2, 1)); show_bar=false, fast_mode=true)\n1\n\njulia> gromov_witten(P2, beta, 2, ev(1, point_class(P2, 1))^2 * ev(2, point_class(P2, 2)); show_bar=false)\nt1^2 - t1*t2 - t1*t3 + t2*t3\n\njulia> gromov_witten(P2, beta, 3, ev(1, point_class(P2, 1)) * ev(2, point_class(P2, 1)) * ev(3, point_class(P2, 3)); show_bar=false)\nt1 - t2\n\n\n\n\n\n","category":"function"},{"location":"GW/GW/#Cohomology-classes-on-the-moduli-space","page":"Gromov–Witten invariants","title":"Cohomology classes on the moduli space","text":"","category":"section"},{"location":"GW/GW/#GKMtools.ev","page":"Gromov–Witten invariants","title":"GKMtools.ev","text":"ev(j::Int64, cc) -> EquivariantClass\n\nReturn the equivariant cohomology class on overlinemathcalM_0n(Xbeta) that is given by pulling back the cohomology class cc on X along the evaluation map at the j-th point: textev_jcolon overlinemathcalM_0n(Xbeta)rightarrow X.\n\nFor example, if cc is a point class, then ev(j, cc) is the pullback of the point class at the j-th marked point. The following invariant:\n\nint_overlineM_02(mathbbP^3 1)mathrmev_1^*(mathrmpt)cdotmathrmev_2^*(mathrmpt) = 1\n\ncan be computed as follows:\n\njulia> G = projective_space(GKM_graph, 3);\n\njulia> P = ev(1, point_class(G, 1)) * ev(2, point_class(G, 2));\n\njulia> beta = curve_class(G, \"1\", \"2\"); # beta is the class of a line in $\\mathbb{P}^3$\n\njulia> gromov_witten(G, beta, 2, P; show_bar=false)\n1\n\nThe following is a more complex example, where we compute the Gromov-Witten invariant of the Grassmannian G(24).\n\nExample\n\njulia> G24 = grassmannian(GKM_graph, 2, 4);\n\njulia> e1 = ev(1, point_class(G24, 1));\n\njulia> e2 = ev(2, first_chern_class(G24));\n\njulia> e3 = ev(3, poincare_dual(gkm_subgraph_from_vertices(G24, [1, 2])));\n\njulia> beta = curve_class(G24, Edge(1, 2));\n\njulia> gromov_witten(G24, beta, 3, e1 * e2 * e3; show_bar=false)\n4\n\n\n\n\n\n","category":"function"},{"location":"GW/GW/#GKMtools.class_one","page":"Gromov–Witten invariants","title":"GKMtools.class_one","text":"class_one() -> EquivariantClass\n\nIt returns the cohomology class 1 on overlinemathcalM_0n(Xbeta). This is useful when overlinemathcalM_0n(Xbeta) is zero dimensional.\n\nExample\n\njulia> F = hirzebruch_surface(NormalToricVariety, 1);\n\njulia> G = gkm_graph_of_toric(F); \n\njulia> beta = curve_class(G, \"1\", \"2\"); # class of the zero section of the Hirzebruch surface\n\njulia> gromov_witten(G, beta, 0, class_one(), show_bar = false)\n1\n\n\n\n\n\n","category":"function"},{"location":"GW/GW/#GKMtools.Psi","page":"Gromov–Witten invariants","title":"GKMtools.Psi","text":"Psi(a) -> EquivariantClass\n\nFor each index i such that 0le i le n, there is a line bundle on overlinemathcalM_0n(Xbeta) such that the fiber at a moduli point is the cotangent bundle of the curve at the i^mathrmth marked point.  We denote by psi_i the first Chern class of this line bundle. In order to compute invariants involving psi_1^a_1cdots psi_n^a_n, for some nonnegative integers  a_1ldots a_n, we write Psi(a_1,...,a_n)\n\nExample\n\nLet G be the GKM graph of the Hirzebruch surface mathbbP(mathcalO_mathbbP^1(0) oplus mathcalO_mathbbP^1(1)), let beta the class of the fiber. The invariant\n\nint_overlineM_02(G beta)mathrmev_1^*(mathrmpt)cdotpsi_1^0psi_2 = -1\n\ncan be computed as following.\n\njulia> G = gkm_graph_of_toric(hirzebruch_surface(NormalToricVariety, 1));\n\njulia> P = ev(1, point_class(G, 1)) * Psi(0,1);\n\njulia> beta = curve_class(G, \"1\", \"4\"); # beta is a fiber of the map G -> P^1\n\njulia> gromov_witten(G, beta, 2, P; show_bar=false)\n-1\n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"Misc/Misc/","page":"Miscellaneous","title":"Miscellaneous","text":"In this section we collect functions that are useful for GKM graphs, but that do not belong to GKM theory.","category":"page"},{"location":"Misc/Misc/#Smoothness-of-Schubert-varieties","page":"Miscellaneous","title":"Smoothness of Schubert varieties","text":"","category":"section"},{"location":"Misc/Misc/#GKMtools.isregular_word","page":"Miscellaneous","title":"GKMtools.isregular_word","text":"isregular_word(w::WeylGroupElem) -> Bool\n\nGiven a Weyl group element w, this function returns true if and only if the Bruhat graph of w is regular. That is, all vertices  have the same number of incident edges. We implemented [BP05, Lemma 5.7].  Note that the Schubert variety given by w is rationally smooth if and only if the Bruhat graph of w is regular. \n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#GKMtools.issmooth_schubert_at_v","page":"Miscellaneous","title":"GKMtools.issmooth_schubert_at_v","text":"issmooth_schubert_at_v(v::WeylGroupElem, w::WeylGroupElem) -> Bool\n\nGiven a Weyl group element w, this function returns true if and only if the Schubert variety given by w is smooth at the point given by v.  We implemented [Kum96, Theorem 5.5], see also [BL00, 7.2.1 Theorem].\n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#GKMtools.issmooth_schubert","page":"Miscellaneous","title":"GKMtools.issmooth_schubert","text":"issmooth_schubert(w::WeylGroupElem) -> Bool\n\nCheck if the Schubert variety given by w is smooth at the point given by the identity element. This is equivalent to the Schubert variety be smooth.\n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#Kazhdan-Lusztig-polynomials","page":"Miscellaneous","title":"Kazhdan-Lusztig polynomials","text":"","category":"section"},{"location":"Misc/Misc/#GKMtools.R_polynomial","page":"Miscellaneous","title":"GKMtools.R_polynomial","text":"R_polynomial(v::WeylGroupElem, w::WeylGroupElem) -> ZZPolyRingElem\n\nGiven two Weyl group elements v,w, with v≤w this function returns the R-polynomial of v,w in the polynomial ring mathbbZq.  See [BL00, Section 6.1].\n\n\n\n\n\n","category":"function"},{"location":"Misc/Misc/#GKMtools.kazhdan_lusztig","page":"Miscellaneous","title":"GKMtools.kazhdan_lusztig","text":"kazhdan_lusztig(v::WeylGroupElem, w::WeylGroupElem) -> ZZPolyRingElem\n\nGiven two Weyl group elements v,w, with v≤w this function returns the Kazhdan-Lusztig polynomial of v,w in the polynomial ring mathbbZq.  See [BL00, Equation (6.1.8)].\n\n\n\n\n\n","category":"function"},{"location":"GW/SeidelElements/#Seidel-elements-/-Shift-operators","page":"Seidel Elements / Shift Operators","title":"Seidel elements / Shift operators","text":"","category":"section"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"This section deals with certain equivariant Gromov–Witten invariants on Seidel spaces. The definition used in this package should be carefully compared to [Iri17, Section 3] and [MO19, Chapter 8] (shift operators). A (non-equivariant) symplectic account can be found in [MS12, Section 11.4] (Seidel representation).","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"Let X be a (smooth projective) GKM variety with torus action by T, and let iotacolon  mathbbC^times rightarrow T be a group homomorphism. This gives rise to the X-bundle picolon S_Xrightarrow mathbbP^1, where S_X is the Seidel space associated to (X iota). Recall that S_X is a GKM space with respect to widehatT= TtimesmathbbC^times, where the extra copy of mathbbC^times acts by rotating the base mathbbP^1.","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"Let (e_i) and (e^i) be dual bases of H_T^*(XmathbbQ) with respect to the T-equivariant Poincaré pairing on X. Note also that we have a H_T^*(textptmathbbQ)-linear pushforward map (i_infty)_*colon H_T^*(XmathbbQ) rightarrow H_widehatT^*(S_XmathbbQ) raising degree by one.","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"Finally, let H_2^textsec(S_XmathbbZ) be the set of effective section curve classes in S_X, i.e., effective curve classes that project to mathbbP^1 under picolon S_XrightarrowmathbbP^1. The additive group H_2^textsec(S_XmathbbZ) is an H_2^texteff(XmathbbZ)-torsor, so after picking some beta_0in H_2^textsec(S_XmathbbZ) there is an identification rcolon H_2^textsec(S_XmathbbZ)stackrelconglongrightarrow H_2^texteff(XmathbbZ) that sends beta_0 to 0.","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"The (equivariant) Seidel element associated to iota is","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"  mathcalS(iota) = sum_betain H_2^textsec(S_XmathbbZ) leftGW^widehatT_01beta((i_infty)_*(e_i))right_hatt = 0 e^i q^r(beta) in QH_T^*(X)","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"where hatt is the equivariant parameter for the extra mathbbC^times in widehatT.","category":"page"},{"location":"GW/SeidelElements/","page":"Seidel Elements / Shift Operators","title":"Seidel Elements / Shift Operators","text":"note: Note\nLet Lambda= textHom(mathbbC^times T) be the cocharacter lattice of T. It is a key property of the equivariant Seidel elements that the map  mathcalScolon Lambda rightarrow QH_T^*(X)^timesis a group homomorphism, where QH_T^*(X)^times is endowed with the equivariant quantum product.","category":"page"},{"location":"#GKMtools.jl","page":"Home","title":"GKMtools.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package is work in progress. It offers support for calculations involving GKM varieties, including their equivariant Gromov-Witten invariants. It requires Oscar. See https://www.oscar-system.org/install/.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It comes with the supporting article: (Work in Progress...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is divided in two parts. The first one deals with foundational material on GKM varieties in general. The second part is dedicated to the computation of equivariant Gromov–Witten invariants, equivariant quantum cohomology and equivariant Seidel elements (shift operators).","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the github page for installation instructions. This is the version under developing.","category":"page"}]
}
